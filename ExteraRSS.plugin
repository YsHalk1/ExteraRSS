import json
import time
import threading
import urllib.request
import urllib.parse
import xml.etree.ElementTree as ET
import re
from typing import Any, Dict, List, Optional, Tuple

from base_plugin import BasePlugin, MenuItemData, MenuItemType
from ui.settings import Header, Divider, Switch, Text

from android_utils import log, run_on_ui_thread, OnClickListener
from client_utils import get_last_fragment
try:
    from hook_utils import get_private_field
except Exception:
    get_private_field = None

from org.telegram.messenger import AndroidUtilities, ApplicationLoader

from android.graphics import Color
from android.graphics import BitmapFactory
from android.graphics import Typeface
try:
    from android.graphics import Bitmap
except Exception:
    Bitmap = None
from android.graphics.drawable import GradientDrawable
from android.view import Gravity, View, ViewGroup, ViewOutlineProvider
from android.view import HapticFeedbackConstants
from android.view.animation import DecelerateInterpolator
try:
    from android.view.animation import OvershootInterpolator
except ImportError:
    OvershootInterpolator = DecelerateInterpolator

from android.widget import FrameLayout, LinearLayout, ScrollView, TextView, ImageView, EditText, SeekBar, Toast
from android.content import Intent
from android.net import Uri

from datetime import datetime, timezone

from java import dynamic_proxy
from java.lang import Runnable
from android.view import MotionEvent, KeyEvent, ViewConfiguration, KeyCharacterMap

try:
    from java.util import Locale as JavaLocale
except Exception:
    JavaLocale = None
from android.widget import ProgressBar

try:
    from android_utils import OnTouchListener as _OnTouchListener
except ImportError:
    class _OnTouchListener(dynamic_proxy(View.OnTouchListener)):
        def __init__(self, fn):
            super().__init__()
            self._fn = fn

        def onTouch(self, v, ev):
            return bool(self._fn(v, ev))

try:
    from android_utils import OnKeyListener as _OnKeyListener
except ImportError:
    class _OnKeyListener(dynamic_proxy(View.OnKeyListener)):
        def __init__(self, fn):
            super().__init__()
            self._fn = fn

        def onKey(self, v, key_code, event):
            return bool(self._fn(v, key_code, event))

try:
    from android_utils import OnLongClickListener as _OnLongClickListener
except ImportError:
    class _OnLongClickListener(dynamic_proxy(View.OnLongClickListener)):
        def __init__(self, fn):
            super().__init__()
            self._fn = fn

        def onLongClick(self, v):
            return bool(self._fn(v))

try:
    from android_utils import OnSeekBarChangeListener as _OnSeekBarChangeListener
except ImportError:
    try:
        class _OnSeekBarChangeListener(dynamic_proxy(SeekBar.OnSeekBarChangeListener)):
            def __init__(self, on_change=None, on_start=None, on_stop=None):
                super().__init__()
                self._on_change = on_change
                self._on_start = on_start
                self._on_stop = on_stop

            def onProgressChanged(self, seek_bar, progress, from_user):
                try:
                    if self._on_change is not None:
                        self._on_change(seek_bar, int(progress), bool(from_user))
                except Exception:
                    pass

            def onStartTrackingTouch(self, seek_bar):
                try:
                    if self._on_start is not None:
                        self._on_start(seek_bar)
                except Exception:
                    pass

            def onStopTrackingTouch(self, seek_bar):
                try:
                    if self._on_stop is not None:
                        self._on_stop(seek_bar)
                except Exception:
                    pass
    except Exception:
        class _OnSeekBarChangeListener:
            def __init__(self, on_change=None, on_start=None, on_stop=None):
                self._on_change = on_change
                self._on_start = on_start
                self._on_stop = on_stop


__id__ = "ExteraRSS"
__name__ = "ExteraRSS"
__description__ = "RSS + Telegram в одной ленте. (UI Obsidian Design)"
__author__ = "@RoflPlugins"
__version__ = "2.0.0"
__icon__ = "RoflPlugins/15"
__min_version__ = "11.12.0"

# ---- UI Palette & Tuning ----
CORNER_RADIUS_DP = 24  # Огромные скругления как в iOS
_UI_SCALE_MIN = 0.80
_UI_SCALE_MAX = 1.35
_UI_SCALE = 1.00
_UI_PAD_MIN = 0
_UI_PAD_MAX = 30
_CORNER_SCALE_MIN = 0.60
_CORNER_SCALE_MAX = 1.80

COLOR_BG = "#FF060608"
COLOR_CARD = "#FF121216"
COLOR_STROKE = "#FF1E1E26"
COLOR_ACCENT = "#FF7E57C2"  # Deep Violet
COLOR_TEXT_PR = "#FFFFFFFF"
COLOR_TEXT_SEC = "#FF8A8A93"
COLOR_OVERLAY = "#D9060608" # Translucent glass


def _clamp_corner_scale(v: Any) -> float:
    try:
        x = float(v)
    except Exception:
        x = 1.00
    if x < _CORNER_SCALE_MIN:
        x = _CORNER_SCALE_MIN
    if x > _CORNER_SCALE_MAX:
        x = _CORNER_SCALE_MAX
    return x


def _norm_accent_hex(v: Any) -> str:
    s = str(v or "").strip().upper()
    if not s:
        return "#FF7E57C2"
    if not s.startswith("#"):
        s = "#" + s
    if len(s) == 7:
        s = "#FF" + s[1:]
    if len(s) != 9:
        return "#FF7E57C2"
    try:
        int(s[1:], 16)
    except Exception:
        return "#FF7E57C2"
    return s


def _mix_hex(c1: Any, c2: Any, ratio: float) -> str:
    a = _norm_accent_hex(c1)
    b = _norm_accent_hex(c2)
    try:
        r = float(ratio)
    except Exception:
        r = 0.5
    if r < 0.0: r = 0.0
    if r > 1.0: r = 1.0
    try:
        a_a = int(a[1:3], 16); a_r = int(a[3:5], 16); a_g = int(a[5:7], 16); a_b = int(a[7:9], 16)
        b_a = int(b[1:3], 16); b_r = int(b[3:5], 16); b_g = int(b[5:7], 16); b_b = int(b[7:9], 16)
        o_a = int(round(a_a * (1.0 - r) + b_a * r))
        o_r = int(round(a_r * (1.0 - r) + b_r * r))
        o_g = int(round(a_g * (1.0 - r) + b_g * r))
        o_b = int(round(a_b * (1.0 - r) + b_b * r))
        return f"#{o_a:02X}{o_r:02X}{o_g:02X}{o_b:02X}"
    except Exception:
        return a


def _with_alpha(c: Any, alpha: int) -> str:
    base = _norm_accent_hex(c)
    try:
        a = int(alpha)
    except Exception:
        a = 255
    if a < 0: a = 0
    if a > 255: a = 255
    return f"#{a:02X}{base[3:]}"

def _clamp_ui_scale(v: Any) -> float:
    try:
        x = float(v)
    except Exception:
        x = 1.00
    if x < _UI_SCALE_MIN:
        x = _UI_SCALE_MIN
    if x > _UI_SCALE_MAX:
        x = _UI_SCALE_MAX
    return x

def _clamp_ui_pad(v: Any) -> int:
    try:
        x = int(round(float(v)))
    except Exception:
        x = 16
    if x < _UI_PAD_MIN:
        x = _UI_PAD_MIN
    if x > _UI_PAD_MAX:
        x = _UI_PAD_MAX
    return x


def _clamp_bg_refresh_seconds(v: Any) -> int:
    try:
        x = int(round(float(v)))
    except Exception:
        x = 180
    if x < 10:
        x = 10
    if x > 1800:
        x = 1800
    return x


def _clamp_history_posts(v: Any) -> int:
    try:
        x = int(round(float(v)))
    except Exception:
        x = 20
    if x < 1:
        x = 1
    if x > 100:
        x = 100
    return x


def _sub_to_label(sub: str) -> str:
    s = _norm_sub(sub)
    if s.startswith("tguser:"):
        return "@" + s.split(":", 1)[1]
    return s

def _is_ru_locale() -> bool:
    try:
        if JavaLocale is not None:
            lang = str(JavaLocale.getDefault().getLanguage() or "").lower()
            return lang.startswith("ru")
    except Exception:
        pass
    return True

def _tr(ru: str, en: str) -> str:
    return ru if _is_ru_locale() else en

# ---------------- safe color ----------------
def _c(hex_color: str, fallback: str = "#FFFFFFFF") -> int:
    try:
        s = (hex_color or "").strip()
        if not s:
            return Color.parseColor(fallback)
        if not s.startswith("#"):
            s = "#" + s
        if len(s) not in (7, 9):
            return Color.parseColor(fallback)
        return Color.parseColor(s)
    except Exception:
        try:
            return Color.parseColor(fallback)
        except Exception:
            return 0xFFFFFFFF

# ---------------- utils ----------------
def _clean_reply_for_ui(reply_raw: str, it: Dict[str, Any]) -> str:
    txt = (reply_raw or "").strip()
    if not txt:
        return ""

    txt = _reply_text_only(txt)
    txt = _strip_leading_handle_line(txt)

    src_title = str(it.get("source_title") or "").strip()
    src_handle = str(it.get("source_handle") or "").strip()
    src_title_plain = src_title.lstrip("@").strip()
    src_handle_plain = src_handle.lstrip("@").strip()

    low = txt.lower().strip()

    def _cut_prefix(prefix: str):
        nonlocal txt, low
        p = (prefix or "").strip()
        if not p:
            return
        plow = p.lower()
        for sep in (" ", ":", " —", " -", " — ", " - "):
            pref = (plow + sep).strip()
            if low.startswith(pref):
                txt = txt[len(p):].lstrip(" \t\r\n:-—|")
                low = txt.lower().strip()
                return

    _cut_prefix(src_title_plain)
    _cut_prefix(src_handle_plain)

    try:
        real_title = str(it.get("source_title") or "").strip()
        if real_title:
            real_title_plain = real_title.strip()
            cand = _norm_name_for_compare(real_title_plain)
            txt_low = _norm_name_for_compare(txt)

            for sep in (":", "—", "-", "|"):
                pref = (cand + " " + sep).strip()
                if txt_low.startswith(pref):
                    txt = txt[len(real_title_plain):].lstrip(" \t\r\n:-—|•·")
                    break

            txt_low = _norm_name_for_compare(txt)
            if txt_low.startswith(cand + " "):
                rest = txt[len(real_title_plain):].lstrip()
                if rest and (rest[0].isalnum() or rest[0] in "@#("):
                    txt = rest
    except Exception:
        pass

    if " — " not in (reply_raw or ""):
        try:
            parts = txt.split()
            if len(parts) >= 3:
                def is_name_word(w: str) -> bool:
                    if not w:
                        return False
                    for ch in w:
                        if not (ch.isalpha() or ch in "’'"):
                            return False
                    return True

                def looks_like_content(w: str) -> bool:
                    if not w:
                        return False
                    if any(x in w for x in (".", "_", "(", ")", "/", "://", "@")):
                        return True
                    if any(ch.isdigit() for ch in w):
                        return True
                    return False

                if is_name_word(parts[0]) and is_name_word(parts[1]) and looks_like_content(parts[2]):
                    txt = " ".join(parts[2:]).strip()
                elif is_name_word(parts[0]) and looks_like_content(parts[1]):
                    txt = " ".join(parts[1:]).strip()
                elif len(parts) >= 4 and is_name_word(parts[0]) and is_name_word(parts[1]) and is_name_word(parts[2]) and looks_like_content(parts[3]):
                    txt = " ".join(parts[3:]).strip()
        except Exception:
            pass

    return txt.strip()

def _reply_text_only(reply_raw: str) -> str:
    s = (reply_raw or "").strip()
    if not s:
        return ""
    if " — " in s:
        parts = s.split(" — ", 1)
        tail = (parts[1] or "").strip()
        return tail if tail else s
    return s

def _ensure_at(src: str) -> str:
    s = (src or "").strip()
    if not s:
        return ""
    if s.startswith("@"):
        return s
    return "@" + s

def _format_source_line(it: Dict[str, Any]) -> str:
    h = (it.get("source_handle") or "").strip()
    t = (it.get("source_title") or "").strip()

    if h and not h.startswith("@"):
        h = "@" + h

    if h and t:
        if t != h:
            return f"{h} – {t}"
        return h

    s = (it.get("source") or "").strip()
    if s and not s.startswith("@") and h:
        return h
    return s or h

def _preview_text(text: str, max_len: int = 200, title: str = "") -> str:
    t = (text or "").strip()
    if not t:
        return ""
    if title:
        first = t.split("\n", 1)[0].strip()
        if first and title.strip() == first:
            t = t.split("\n", 1)[1].strip() if "\n" in t else ""
    if not t:
        return ""
    t = re.sub(r"\s+", " ", t).strip()
    if len(t) <= max_len:
        return t
    return t[:max_len - 1].rstrip() + "…"

def _dp(x: float) -> int:
    return AndroidUtilities.dp(float(x) * float(_UI_SCALE))

def _safe_json_load(s: Any, default):
    try:
        if isinstance(s, str) and s.strip():
            return json.loads(s)
    except Exception:
        pass
    return default

def _now_ts() -> int:
    return int(time.time())

def _strip_ns(tag: str) -> str:
    if "}" in tag:
        return tag.split("}", 1)[1]
    return tag

def _text(node) -> str:
    if node is None:
        return ""
    return (node.text or "").strip()

def _join_text(node) -> str:
    if node is None:
        return ""
    parts = []
    try:
        for t in node.itertext():
            if t:
                parts.append(t)
    except Exception:
        pass
    return (" ".join(parts)).strip()

def _uniq_keep_order(lst: List[str]) -> List[str]:
    seen = set()
    out = []
    for x in lst:
        if x in seen:
            continue
        seen.add(x)
        out.append(x)
    return out

def _statusbar_pad() -> int:
    try:
        sb = int(getattr(AndroidUtilities, "statusBarHeight", 0))
        if sb > 0:
            return sb
    except Exception:
        pass
    return _dp(24)

def _norm_sub(line: str) -> Optional[str]:
    if not isinstance(line, str):
        return None
    s = line.strip()
    if not s:
        return None

    def _norm_username(u: str) -> Optional[str]:
        x = str(u or "").strip().strip("/")
        if not x:
            return None
        x = x.split("?", 1)[0].split("#", 1)[0].strip()
        if x.startswith("@"):
            x = x[1:].strip()
        if not x:
            return None
        if re.match(r"^[A-Za-z][A-Za-z0-9_]{3,31}$", x):
            return "tguser:" + x
        return None

    if s.startswith("tguser:"):
        u = s.split(":", 1)[1].strip()
        return _norm_username(u)

    if s.startswith("@"):
        return _norm_username(s)

    low = s.lower()
    if low.startswith("t.me/s/") or low.startswith("telegram.me/s/"):
        return _norm_username(s.split("/s/", 1)[1])

    if low.startswith("t.me/") or low.startswith("telegram.me/"):
        m = re.match(r"^(?:t\.me|telegram\.me)/(?:s/)?([^/?#]+)", s, re.I)
        if m:
            return _norm_username(m.group(1) or "")
        return None

    if low.startswith("http://") or low.startswith("https://"):
        m = re.match(r"^https?://(?:www\.)?(?:t\.me|telegram\.me)/(?:s/)?([^/?#]+)", s, re.I)
        if m:
            return _norm_username(m.group(1) or "")
        return s

    u = _norm_username(s)
    if u:
        return u
    return None

def _norm_category(raw: Any) -> str:
    s = str(raw or "").strip()
    if not s:
        return ""
    s = re.sub(r"\s+", " ", s).strip()
    return s[:42]

def _norm_image_url(raw: Any) -> str:
    u = str(raw or "").strip()
    if not u:
        return ""
    if u.startswith("//"):
        u = "https:" + u
    return u

def _upgrade_image_url(raw: Any) -> str:
    u = _norm_image_url(raw)
    if not u:
        return ""
    try:
        p = urllib.parse.urlsplit(u)
        if not p.query:
            return u
        q = urllib.parse.parse_qsl(p.query, keep_blank_values=True)
        out_q = []
        for k, v in q:
            lk = str(k or "").lower()
            lv = str(v or "").lower()
            if lk in ("w", "h", "width", "height", "size"):
                continue
            if lk == "name" and lv in ("small", "medium"):
                out_q.append((k, "orig"))
                continue
            out_q.append((k, v))
        new_q = urllib.parse.urlencode(out_q, doseq=True)
        return urllib.parse.urlunsplit((p.scheme, p.netloc, p.path, new_q, p.fragment))
    except Exception:
        return u

def _norm_images_list(raw: Any) -> List[str]:
    arr = raw if isinstance(raw, list) else [raw]
    out: List[str] = []
    seen = set()
    for x in arr:
        u = _upgrade_image_url(x)
        if not u or u in seen:
            continue
        seen.add(u)
        out.append(u)
    return out

def _html_unescape_basic(s: str) -> str:
    if not s:
        return ""
    s = s.replace("&nbsp;", " ").replace("&quot;", "\"").replace("&apos;", "'").replace("&lt;", "<").replace("&gt;", ">").replace("&amp;", "&")
    def _rep_num(m):
        try:
            code = int(m.group(1))
            if 0 <= code <= 0x10FFFF:
                return chr(code)
        except Exception:
            pass
        return m.group(0)
    def _rep_hex(m):
        try:
            code = int(m.group(1), 16)
            if 0 <= code <= 0x10FFFF:
                return chr(code)
        except Exception:
            pass
        return m.group(0)
    s = re.sub(r"&#(\d+);", _rep_num, s)
    s = re.sub(r"&#x([0-9a-fA-F]+);", _rep_hex, s)
    return s

def _strip_tags_and_format(s: str) -> str:
    if not s:
        return ""
    x = s
    x = x.replace("<br/>", "\n").replace("<br />", "\n").replace("<br>", "\n")
    x = x.replace("</p>", "\n").replace("<p>", "")
    x = x.replace("</div>", "\n").replace("<div>", "")
    x = x.replace("</li>", "\n").replace("<li>", "• ")
    x = x.replace("</ul>", "\n").replace("<ul>", "")
    x = x.replace("</ol>", "\n").replace("<ol>", "")
    out = []
    in_tag = False
    for ch in x:
        if ch == "<":
            in_tag = True
            continue
        if ch == ">":
            in_tag = False
            continue
        if not in_tag:
            out.append(ch)
    x = "".join(out)
    x = _html_unescape_basic(x)
    x = x.replace("\r\n", "\n").replace("\r", "\n")
    lines = [ln.strip() for ln in x.split("\n")]
    cleaned = []
    empty_run = 0
    for ln in lines:
        if not ln:
            empty_run += 1
            if empty_run <= 1:
                cleaned.append("")
        else:
            empty_run = 0
            cleaned.append(ln)
    return "\n".join(cleaned).strip()

_RSS_MONTHS = {
    "jan": 1, "feb": 2, "mar": 3, "apr": 4, "may": 5, "jun": 6,
    "jul": 7, "aug": 8, "sep": 9, "oct": 10, "nov": 11, "dec": 12
}

def _parse_rfc822_dt(s: str) -> Optional[datetime]:
    if not s: return None
    x = s.strip()
    if "," in x:
        parts = x.split(",", 1)
        if len(parts) == 2 and len(parts[0].strip()) <= 4:
            x = parts[1].strip()
    x = x.replace(" GMT", " +0000").replace(" UT", " +0000").replace(" UTC", " +0000")
    toks = x.split()
    if len(toks) < 4: return None
    try:
        day = int(toks[0])
        mon = _RSS_MONTHS.get(toks[1].lower(), 0)
        if mon <= 0: return None
        year = int(toks[2])
        hh, mm, ss = 0, 0, 0
        tt = toks[3].split(":")
        if len(tt) >= 2:
            hh = int(tt[0])
            mm = int(tt[1])
        if len(tt) >= 3:
            ss = int(tt[2])
        tz = None
        if len(toks) >= 5:
            z = toks[4].strip().replace(":", "")
            if z and (z[0] in "+-" and len(z) == 5):
                sign = 1 if z[0] == "+" else -1
                zh = int(z[1:3])
                zm = int(z[3:5])
                tz = timezone(sign * (zh * 3600 + zm * 60))
        if tz is None:
            tz = timezone.utc
        return datetime(year, mon, day, hh, mm, ss, tzinfo=tz)
    except Exception:
        return None

def _parse_iso8601_dt(s: str) -> Optional[datetime]:
    if not s: return None
    x = s.strip()
    try:
        if x.endswith("Z"):
            x = x[:-1] + "+00:00"
        return datetime.fromisoformat(x)
    except Exception:
        try:
            base = x[:19]
            dt = datetime.strptime(base, "%Y-%m-%dT%H:%M:%S")
            return dt.replace(tzinfo=timezone.utc)
        except Exception:
            return None

def _parse_published_to_ts(published: str) -> int:
    if not published: return 0
    dt = _parse_rfc822_dt(published) or _parse_iso8601_dt(published)
    if dt is None: return 0
    try:
        if dt.tzinfo is None:
            dt = dt.replace(tzinfo=timezone.utc)
        return int(dt.timestamp())
    except Exception:
        return 0

def _format_ru_datetime(ts: int) -> str:
    if not ts: return ""
    try:
        lt = time.localtime(int(ts))
        return time.strftime("%d.%m.%Y %H:%M", lt)
    except Exception:
        return ""

def _http_get(url: str, timeout_sec: int = 12) -> bytes:
    req = urllib.request.Request(url, headers={"User-Agent": "Exteragram-RSS-Plugin/2.0.0"})
    with urllib.request.urlopen(req, timeout=timeout_sec) as resp:
        return resp.read()

def _best_image_from_rss_item(it: ET.Element) -> str:
    arr = _all_images_from_rss_item(it)
    return arr[0] if arr else ""

def _all_images_from_rss_item(it: ET.Element) -> List[str]:
    out: List[str] = []
    try:
        for enc in it.findall("enclosure"):
            url = (enc.attrib.get("url") or "").strip()
            typ = (enc.attrib.get("type") or "").strip().lower()
            if url and (typ.startswith("image/") or url.lower().endswith((".jpg", ".jpeg", ".png", ".webp"))):
                out.append(url)
    except Exception: pass
    try:
        for el in it.iter():
            name = _strip_ns(el.tag).lower()
            if name in ("thumbnail", "content"):
                url = (el.attrib.get("url") or el.attrib.get("src") or "").strip()
                typ = (el.attrib.get("type") or "").strip().lower()
                if url and (typ.startswith("image/") or url.lower().endswith((".jpg", ".jpeg", ".png", ".webp"))):
                    out.append(url)
    except Exception: pass
    return _norm_images_list(out)

_RE_LEADING_HANDLE = re.compile(r"^\s*@[\w\d_]{3,32}\s*:\s*", re.I)

def _norm_name_for_compare(s: str) -> str:
    x = (s or "").strip().lower()
    x = re.sub(r"\s+", " ", x).strip()
    x = x.strip(":-—|•·")
    return x

def _strip_leading_handle_line(s: str) -> str:
    if not s: return ""
    lines = s.split("\n")
    if not lines: return s
    if _RE_LEADING_HANDLE.match(lines[0].strip()):
        return "\n".join(lines[1:]).lstrip()
    return s

def _best_image_from_atom_entry(e: ET.Element) -> str:
    arr = _all_images_from_atom_entry(e)
    return arr[0] if arr else ""

def _all_images_from_atom_entry(e: ET.Element) -> List[str]:
    out: List[str] = []
    try:
        for l in e.iter():
            if _strip_ns(l.tag).lower() != "link": continue
            href = (l.attrib.get("href") or "").strip()
            rel = (l.attrib.get("rel") or "").strip().lower()
            typ = (l.attrib.get("type") or "").strip().lower()
            if href and rel == "enclosure" and (typ.startswith("image/") or href.lower().endswith((".jpg", ".jpeg", ".png", ".webp"))):
                out.append(href)
    except Exception: pass
    try:
        for el in e.iter():
            name = _strip_ns(el.tag).lower()
            if name in ("thumbnail", "content"):
                url = (el.attrib.get("url") or el.attrib.get("src") or "").strip()
                typ = (el.attrib.get("type") or "").strip().lower()
                if url and (typ.startswith("image/") or url.lower().endswith((".jpg", ".jpeg", ".png", ".webp"))):
                    out.append(url)
    except Exception: pass
    return _norm_images_list(out)

def parse_feed(xml_bytes: bytes, source_url: str) -> Tuple[str, List[Dict[str, Any]]]:
    items: List[Dict[str, Any]] = []
    try: root = ET.fromstring(xml_bytes)
    except Exception: return (source_url, items)
    root_name = _strip_ns(root.tag).lower()

    if root_name == "rss":
        channel = root.find("channel")
        if channel is None: return (source_url, items)
        src_title = _text(channel.find("title")) or source_url
        for it in channel.findall("item"):
            title = _text(it.find("title"))
            link = _text(it.find("link"))
            pub_raw = _text(it.find("pubDate")) or _text(it.find("date"))
            if not pub_raw:
                try:
                    for el in it.iter():
                        n = _strip_ns(el.tag).lower()
                        if n in ("date", "pubdate", "updated", "published"):
                            v = _join_text(el)
                            if v: pub_raw = v.strip(); break
                except Exception: pass
            if not link:
                guid = _text(it.find("guid"))
                if guid.startswith("http://") or guid.startswith("https://"): link = guid
            desc = _join_text(it.find("description"))
            if not desc:
                try:
                    for el in it.iter():
                        if _strip_ns(el.tag).lower() in ("encoded", "content"):
                            txt = _join_text(el)
                            if txt: desc = txt; break
                except Exception: pass
            images = _all_images_from_rss_item(it)
            img = images[0] if images else ""
            ts = _parse_published_to_ts(pub_raw)
            if link:
                items.append({"title": title, "link": link, "published_raw": pub_raw, "ts": ts, "source": src_title, "text": desc, "image": img, "images": images})
        return (src_title, items)

    if root_name == "feed":
        ns = ""
        if root.tag.startswith("{") and "}" in root.tag:
            ns = root.tag.split("}", 1)[0].strip("{")
        def q(name: str) -> str: return f"{{{ns}}}{name}" if ns else name
        src_title = _text(root.find(q("title"))) or source_url
        for e in root.findall(q("entry")):
            title = _text(e.find(q("title")))
            pub_raw = _text(e.find(q("updated"))) or _text(e.find(q("published")))
            link = ""
            for l in e.findall(q("link")):
                href = l.attrib.get("href", "")
                rel = l.attrib.get("rel", "")
                if href and (rel == "" or rel == "alternate"):
                    link = href; break
            desc = _join_text(e.find(q("summary"))) or _join_text(e.find(q("content")))
            images = _all_images_from_atom_entry(e)
            img = images[0] if images else ""
            ts = _parse_published_to_ts(pub_raw)
            if link:
                items.append({"title": title, "link": link, "published_raw": pub_raw, "ts": ts, "source": src_title, "text": desc, "image": img, "images": images})
        return (src_title, items)
    return (source_url, items)

# ---------------- Telegram local (t.me/s/<username>) ----------------
_RE_TG_WRAP = re.compile(r"<div[^>]+class=['\"][^'\"]*\btgme_widget_message_wrap\b[^'\"]*['\"][^>]*>(.*?)</div>\s*</div>\s*</div>", re.S | re.I)
_RE_TG_TIME = re.compile(r"<time[^>]+datetime=['\"]([^'\"]+)['\"]", re.S | re.I)
_RE_TG_TEXT = re.compile(r"<div[^>]+class=['\"][^'\"]*\btgme_widget_message_text\b[^'\"]*['\"][^>]*>(.*?)</div>", re.S | re.I)
_RE_TG_CAPTION = re.compile(r"<div[^>]+class=['\"][^'\"]*\btgme_widget_message_caption\b[^'\"]*['\"][^>]*>(.*?)</div>", re.S | re.I)
_RE_TG_PHOTO_STYLE = re.compile(r"tgme_widget_message_photo_wrap[^>]*style=['\"][^'\"]*url\((?:'|\")?([^'\")]+)", re.S | re.I)
_RE_TG_VIDEO_STYLE = re.compile(r"tgme_widget_message_video_thumb[^>]*style=['\"][^'\"]*url\((?:'|\")?([^'\")]+)", re.S | re.I)
_RE_TG_STICKER_IMG = re.compile(r"tgme_widget_message_sticker[^>]*src=['\"]([^'\"]+)['\"]", re.S | re.I)
_RE_TG_MSG_ID = re.compile(r"data-post=['\"]([^'\"]+)['\"]", re.S | re.I)
_RE_TG_DOC_NAME = re.compile(r"<div[^>]+class=['\"][^'\"]*\btgme_widget_message_document_name\b[^'\"]*['\"][^>]*>(.*?)</div>", re.S | re.I)
_RE_TG_VOICE_DURATION = re.compile(r"<div[^>]+class=['\"][^'\"]*\btgme_widget_message_(?:voice|audio)_duration\b[^'\"]*['\"][^>]*>(.*?)</div>", re.S | re.I)
_RE_TG_VOICE_TITLE = re.compile(r"<div[^>]+class=['\"][^'\"]*\btgme_widget_message_(?:voice|audio)_title\b[^'\"]*['\"][^>]*>(.*?)</div>", re.S | re.I)
_RE_TG_VOICE_LABEL = re.compile(r"aria-label=['\"]([^'\"]*(?:voice|audio|голос|подкаст)[^'\"]*)['\"]", re.S | re.I)
_RE_TG_TEXT_JS = re.compile(r"<div[^>]+class=['\"][^'\"]*\bjs-message_text\b[^'\"]*['\"][^>]*>(.*?)</div>", re.S | re.I)
_RE_TG_BUBBLE = re.compile(r"<div[^>]+class=['\"][^'\"]*\btgme_widget_message_bubble\b[^'\"]*['\"][^>]*>(.*?)<div[^>]+class=['\"][^'\"]*\btgme_widget_message_footer\b", re.S | re.I)
_RE_TG_FOOTER = re.compile(r"<div[^>]+class=['\"][^'\"]*\btgme_widget_message_footer\b[^'\"]*['\"][^>]*>.*?</div>", re.S | re.I)
_RE_TG_REPLY_TEXT = re.compile(r"<(?P<tag>\w+)[^>]*class=['\"][^'\"]*\btgme_widget_message_reply_text\b[^'\"]*['\"][^>]*>(?P<inner>.*?)</(?P=tag)>", re.S | re.I)
_RE_TG_REPLY_TEXT_ALT = re.compile(r"<(?P<tag>\w+)[^>]*class=['\"][^'\"]*\btgme_widget_message_reply_snippet\b[^'\"]*['\"][^>]*>(?P<inner>.*?)</(?P=tag)>", re.S | re.I)
_RE_TG_REPLY_BLOCK = re.compile(r"<(?P<tag>a|div|span)[^>]*class=['\"][^'\"]*\btgme_widget_message_reply\b[^'\"]*['\"][^>]*>[\s\S]*?</(?P=tag)>", re.S | re.I)
_RE_TG_REPLY_BLOCK_INNER = re.compile(r"<(?P<tag>a|div|span)[^>]*class=['\"][^'\"]*\btgme_widget_message_reply\b[^'\"]*['\"][^>]*>(?P<inner>[\s\S]*?)</(?P=tag)>", re.S | re.I)
_RE_TG_PAGE_TITLE = re.compile(r'<div[^>]+class=["\']tgme_page_title["\'][^>]*>\s*(?:<span[^>]*>)?\s*(.*?)\s*(?:</span>)?\s*</div>', re.S | re.I)
_RE_OG_TITLE = re.compile(r'<meta[^>]+property=["\']og:title["\'][^>]+content=["\']([^"\']+)["\']', re.S | re.I)
_RE_OG_DESC = re.compile(r'<meta[^>]+property=["\']og:description["\'][^>]+content=["\']([^"\']*)["\']', re.S | re.I)

def _extract_tg_channel_title(html: str, username: str) -> str:
    if not html: return f"@{username}"
    try:
        m = _RE_TG_PAGE_TITLE.search(html)
        if m:
            t = _strip_tags_and_format(m.group(1) or "").strip()
            if t: return t
    except Exception: pass
    try:
        m = _RE_OG_TITLE.search(html)
        if m:
            t = _strip_tags_and_format(m.group(1) or "").strip()
            t = t.replace("— Telegram", "").replace("- Telegram", "").strip()
            if t: return t
    except Exception: pass
    return f"@{username}"

def _extract_tg_og_description(html: str) -> str:
    if not html: return ""
    try:
        m = _RE_OG_DESC.search(html)
        if m: return _strip_tags_and_format(m.group(1) or "").strip()
    except Exception: pass
    return ""

def _extract_tg_reply(block_html: str) -> str:
    if not block_html: return ""
    if "tgme_widget_message_reply" not in block_html: return ""
    try:
        text = ""
        mt = _RE_TG_REPLY_TEXT.search(block_html)
        if mt: text = _strip_tags_and_format(mt.group("inner") or "").strip()
        if not text:
            mt2 = _RE_TG_REPLY_TEXT_ALT.search(block_html)
            if mt2: text = _strip_tags_and_format(mt2.group("inner") or "").strip()
        if not text:
            m = _RE_TG_REPLY_BLOCK_INNER.search(block_html)
            if m:
                raw = _strip_tags_and_format(m.group("inner") or "").strip()
                raw = re.sub(r"\s+", " ", raw).strip()
                text = raw
        text = (text or "").strip()
        if not text: return ""
        if text.lower() in ("test", "тест"): return ""
        return text[:180]
    except Exception: return ""

def _extract_tg_doc_name(block_html: str) -> str:
    m = _RE_TG_DOC_NAME.search(block_html)
    if not m: return ""
    return _strip_tags_and_format(m.group(1) or "").strip()

def _extract_tg_voice_label(block_html: str) -> str:
    if not block_html: return ""
    has_audio_tag = ("<audio" in block_html.lower())
    try:
        if ("voice" not in block_html.lower()) and ("audio" not in block_html.lower()) and ("голос" not in block_html.lower()): return ""
    except Exception: pass
    title = ""
    dur = ""
    try:
        m_t = _RE_TG_VOICE_TITLE.search(block_html)
        if m_t: title = _strip_tags_and_format(m_t.group(1) or "").strip()
    except Exception: pass
    try:
        m_d = _RE_TG_VOICE_DURATION.search(block_html)
        if m_d: dur = _strip_tags_and_format(m_d.group(1) or "").strip()
    except Exception: pass
    if title and dur: return f"{title} ({dur})"
    if title: return title
    if dur: return _tr(f"Голосовое сообщение ({dur})", f"Voice message ({dur})")
    try:
        m_l = _RE_TG_VOICE_LABEL.search(block_html)
        if m_l:
            raw = _strip_tags_and_format(m_l.group(1) or "").strip()
            if raw: return raw[:120]
    except Exception: pass
    if has_audio_tag: return _tr("Аудио-сообщение", "Audio message")
    return ""

def _all_tg_media_urls(block_html: str) -> List[str]:
    urls: List[str] = []
    try:
        for m in _RE_TG_PHOTO_STYLE.finditer(block_html or ""): urls.append((m.group(1) or "").strip())
    except Exception: pass
    try:
        for m in _RE_TG_VIDEO_STYLE.finditer(block_html or ""): urls.append((m.group(1) or "").strip())
    except Exception: pass
    try:
        for m in _RE_TG_STICKER_IMG.finditer(block_html or ""): urls.append((m.group(1) or "").strip())
    except Exception: pass
    return _norm_images_list(urls)

def _extract_tg_text(block_html: str) -> str:
    if not block_html: return ""
    m_b = _RE_TG_BUBBLE.search(block_html)
    scope = m_b.group(1) if m_b else block_html
    scope = _RE_TG_REPLY_BLOCK.sub("", scope)
    scope = _RE_TG_FOOTER.sub("", scope)
    candidates = []
    try: candidates += [m.group(1) for m in _RE_TG_TEXT.finditer(scope) if m and m.group(1)]
    except Exception: pass
    if not candidates:
        try: candidates += [m.group(1) for m in _RE_TG_TEXT_JS.finditer(scope) if m and m.group(1)]
        except Exception: pass
    if not candidates:
        try: candidates += [m.group(1) for m in _RE_TG_CAPTION.finditer(scope) if m and m.group(1)]
        except Exception: pass
    if not candidates: return ""
    return _strip_tags_and_format(candidates[-1])

def _parse_tg_preview_page(html: str, username: str, channel_title: str) -> Tuple[str, List[Dict[str, Any]]]:
    src_handle = f"@{username}"
    src_title = (channel_title or src_handle).strip()
    items: List[Dict[str, Any]] = []
    blocks = _split_tg_blocks(html)
    if not blocks: blocks = _RE_TG_WRAP.findall(html)
    for b in blocks[:160]:
        try:
            dt_iso = _extract_tg_time_iso(b)
            ts = _parse_published_to_ts(dt_iso)
            post_link = f"https://t.me/s/{username}"
            tg_post_id = ""
            m2 = _RE_TG_MSG_ID.search(b)
            if m2:
                mid = (m2.group(1) or "").strip()
                if mid:
                    tg_post_id = mid
                    if "/" in mid: post_link = f"https://t.me/{mid}"
            text = _extract_tg_text(b)
            text = _strip_leading_handle_line(text)
            reply = _extract_tg_reply(b)
            doc_name = _extract_tg_doc_name(b)
            voice_label = _extract_tg_voice_label(b)
            if text:
                first = text.split("\n", 1)[0].strip()
                first = _RE_LEADING_HANDLE.sub("", first).strip()
                title = first[:120] if first else ""
            elif reply: title = reply[:120]
            elif doc_name: title = doc_name[:120]
            elif voice_label: title = voice_label[:120]
            else: title = ""
            images = _all_tg_media_urls(b)
            img = images[0] if images else ""
            items.append({
                "source": src_title, "source_handle": src_handle, "source_title": src_title,
                "title": title, "link": post_link, "tg_post_id": tg_post_id,
                "published_raw": dt_iso, "ts": ts, "text": text, "image": img,
                "images": images, "reply": reply, "doc": doc_name, "voice": voice_label,
            })
        except Exception: continue
    return (src_title, items)

_DIVTAG = re.compile(r"</div\s*>|<div\b", re.I)

def _split_tg_blocks(html: str) -> List[str]:
    if not html: return []
    marks = [m.start() for m in re.finditer(r"tgme_widget_message_wrap", html)]
    if not marks: return []
    out: List[str] = []
    n = len(html)
    for pos in marks[:220]:
        start = html.rfind("<div", 0, pos)
        if start < 0: continue
        depth = 0
        i = start
        end = -1
        while i < n:
            m = _DIVTAG.search(html, i)
            if not m: break
            tok = m.group(0).lower()
            if tok.startswith("<div"): depth += 1
            else:
                depth -= 1
                if depth == 0: end = m.end(); break
            i = m.end()
        if end > start: out.append(html[start:end])
    return out

def _extract_tg_time_iso(block_html: str) -> str:
    m = _RE_TG_TIME.search(block_html)
    if m: return (m.group(1) or "").strip()
    m2 = re.search(r"datetime=['\"]([^'\"]+)['\"]", block_html, re.S | re.I)
    if m2: return (m2.group(1) or "").strip()
    return ""

def _fetch_tg_user_feed(username: str) -> Tuple[str, List[Dict[str, Any]]]:
    url = f"https://t.me/s/{username}"
    data = _http_get(url, timeout_sec=14)
    try: html = data.decode("utf-8", errors="ignore")
    except Exception: html = str(data)
    ch_title = _extract_tg_channel_title(html, username)
    src_title, items = _parse_tg_preview_page(html, username, ch_title)
    if not items:
        desc = _extract_tg_og_description(html)
        if not desc: desc = _tr(f"Посты канала @{username} недоступны в web-preview. Откройте канал в Telegram.", f"Posts from @{username} are unavailable in web preview. Open the channel in Telegram.")
        items = [{"source": src_title, "source_handle": f"@{username}", "source_title": src_title, "title": src_title, "link": f"https://t.me/{username}", "tg_post_id": f"{username}/channel_preview", "published_raw": "", "ts": 0, "text": desc, "image": "", "images": [], "reply": "", "doc": "", "voice": ""}]
    return (src_title, items)

# ---------------- Plugin ----------------
class Plugin(BasePlugin):
    def __init__(self):
        super().__init__()
        self._overlay: Optional[FrameLayout] = None
        self._main_frame: Optional[FrameLayout] = None
        self._list_container: Optional[LinearLayout] = None
        self._add_overlay: Optional[FrameLayout] = None
        self._add_content: Optional[LinearLayout] = None
        self._cat_overlay: Optional[FrameLayout] = None
        self._cat_content: Optional[LinearLayout] = None
        self._src_overlay: Optional[FrameLayout] = None
        self._src_content: Optional[LinearLayout] = None
        self._post_overlay: Optional[FrameLayout] = None
        self._post_content: Optional[LinearLayout] = None
        self._img_overlay: Optional[FrameLayout] = None
        self._img_content: Optional[LinearLayout] = None

        self._mode: str = "feed"
        self._refresh_lock = threading.Lock()
        self._img_cache: Dict[str, Any] = {}
        self._img_cache_lock = threading.Lock()
        self._refreshing = False
        self._pull_armed = False

        self._main_scroll: Optional[ScrollView] = None
        self._refresh_bar: Optional[View] = None
        self._main_touch_listener = None
        self._main_back_listener = None
        self._add_back_listener = None
        self._cat_back_listener = None
        self._src_back_listener = None
        self._post_back_listener = None
        self._img_back_listener = None
        self._mini_back_listener = None
        self._mini_overlay: Optional[FrameLayout] = None
        self._mini_link: str = ""
        self._back_tracking_paused = False
        self._pencil_hook_view: Optional[View] = None
        self._pencil_touch_listener = None
        self._pencil_long_click_listener = None
        self._pencil_touch_token = 0
        self._pencil_press_armed = False
        self._pencil_down_x = 0.0
        self._pencil_down_y = 0.0
        self._pencil_touch_slop = 0

        self._source_filter: str = ""
        self._category_filter: str = ""
        self._source_exclude_filters: List[str] = []
        self._category_exclude_filters: List[str] = []
        self._sub_exclude_filters: List[str] = []
        self._source_btn: Optional[TextView] = None
        self._nav_feed_btn: Optional[TextView] = None
        self._nav_subs_btn: Optional[TextView] = None
        self._nav_cats_btn: Optional[TextView] = None
        self._nav_settings_btn: Optional[TextView] = None
        self._bottom_nav_row: Optional[LinearLayout] = None

        self._gesture_start_x = 0.0
        self._gesture_start_y = 0.0
        self._gesture_switched = False
        self._animate_list_once = False
        self._feed_item_touch_listener = None

        self._ui_scale = _clamp_ui_scale(self.get_setting("ui_scale", "1.00"))
        self._ui_pad = _clamp_ui_pad(self.get_setting("ui_pad", "16"))
        self._corner_scale = _clamp_corner_scale(self.get_setting("ui_corner_scale", "1.00"))
        self._accent_color = _norm_accent_hex(self.get_setting("ui_accent", COLOR_ACCENT))
        self._history_posts = _clamp_history_posts(self.get_setting("history_posts_limit", "20"))
        global _UI_SCALE
        _UI_SCALE = float(self._ui_scale)
        self._ui_seek_listener = None
        self._ui_pad_seek_listener = None
        self._history_seek_listener = None
        self._corner_seek_listener = None
        self._accent_seek_listener = None
        self._suppress_open_refresh_once = False
        self._bg_thread_running = False
        self._unread_new_posts = max(0, int(self.get_setting("rss_unread_new", "0") or 0))
        self._img_preview_mode = str(self.get_setting("feed_img_preview_mode", "compact") or "compact").strip().lower()
        self._post_img_layout_mode = str(self.get_setting("post_img_layout_mode", "primary") or "primary").strip().lower()
        src_ex_raw = self.get_setting("source_exclude_filters", "")
        if not src_ex_raw:
            src_old = str(self.get_setting("source_exclude_filter", "") or "")
            self._source_exclude_filters = ([src_old] if src_old else [])
        else:
            src_arr = _safe_json_load(src_ex_raw, [])
            self._source_exclude_filters = [str(x) for x in src_arr if str(x or "").strip()]

        cat_ex_raw = self.get_setting("category_exclude_filters", "")
        if not cat_ex_raw:
            cat_old = _norm_category(self.get_setting("category_exclude_filter", "") or "")
            self._category_exclude_filters = ([cat_old] if cat_old else [])
        else:
            cat_arr = _safe_json_load(cat_ex_raw, [])
            self._category_exclude_filters = [_norm_category(x) for x in cat_arr if _norm_category(x)]
        sub_ex_raw = self.get_setting("sub_exclude_filters", "")
        sub_ex_arr = _safe_json_load(sub_ex_raw, []) if sub_ex_raw else []
        self._sub_exclude_filters = [_norm_sub(x) for x in sub_ex_arr if _norm_sub(x)]
        if self._img_preview_mode not in ("compact", "full"):
            self._img_preview_mode = "compact"
        if self._post_img_layout_mode not in ("primary", "grid"):
            self._post_img_layout_mode = "primary"
        self._refresh_fade_token = 0
        self._bg_minutes_seek_listener = None

    # ---- Animations Helpers ----
    def _reset_press_state(self, v: Optional[View]):
        if v is None: return
        try: v.animate().cancel()
        except Exception: pass
        try: v.setPressed(False)
        except Exception: pass
        try: v.setScaleX(1.0)
        except Exception: pass
        try: v.setScaleY(1.0)
        except Exception: pass

    def _bounce_anim(self, v: View):
        self._reset_press_state(v)
        try:
            v.performHapticFeedback(HapticFeedbackConstants.KEYBOARD_TAP)
        except Exception:
            pass
        try:
            v.animate().scaleX(0.93).scaleY(0.93).setDuration(70).withEndAction(
                Runnable(lambda: v.animate().scaleX(1.0).scaleY(1.0).setDuration(130).withEndAction(Runnable(lambda: self._reset_press_state(v))).start())
            ).start()
        except Exception:
            self._reset_press_state(v)

    def _slide_up_enter(self, overlay: View, content: View):
        try:
            overlay.setAlpha(0.0)
            content.setTranslationY(float(_dp(150)))
            overlay.animate().alpha(1.0).setDuration(220).start()
            anim = content.animate().translationY(0.0).setDuration(350)
            try:
                anim.setInterpolator(OvershootInterpolator(0.8))
            except Exception:
                anim.setInterpolator(DecelerateInterpolator())
            anim.start()
        except Exception:
            pass

    def _slide_down_exit(self, overlay: View, content: View):
        try:
            overlay.animate().alpha(0.0).setDuration(180).start()
            content.animate().translationY(float(_dp(100))).setDuration(200).start()
        except Exception:
            pass

    def _animate_entry(self, v: View, idx: int = 0):
        try:
            delay = int(min(max(idx, 0), 12) * 20)
            v.setAlpha(0.0)
            v.setTranslationY(float(_dp(40)))
            anim = v.animate().alpha(1.0).translationY(0.0).setDuration(350)
            try:
                anim.setStartDelay(delay)
                anim.setInterpolator(DecelerateInterpolator())
            except Exception:
                pass
            anim.start()
        except Exception:
            try:
                v.setAlpha(1.0)
                v.setTranslationY(0.0)
            except Exception:
                pass

    # ---- UI helpers ----
    def _bg_rounded(self, fill_hex: str, stroke_hex: str = "#00000000", stroke_dp: float = 0.0, radius_dp: float = CORNER_RADIUS_DP):
        bg = GradientDrawable()
        bg.setColor(_c(fill_hex))
        bg.setCornerRadius(float(_dp(radius_dp * float(self._corner_scale))))
        if stroke_dp and stroke_dp > 0:
            bg.setStroke(_dp(stroke_dp), _c(stroke_hex))
        return bg

    def _bg_important_gradient(self):
        try:
            accent_soft = _with_alpha(self._accent(), 110)
            grad_top = _mix_hex(accent_soft, "#FF2A1A3A", 0.62)
            grad_bottom = _mix_hex(accent_soft, "#FF1A1224", 0.80)
            grad_stroke = _mix_hex(accent_soft, "#FF4A2555", 0.45)
            bg = GradientDrawable(
                GradientDrawable.Orientation.TL_BR,
                [_c(grad_top), _c(grad_bottom)]
            )
            bg.setCornerRadius(float(_dp(CORNER_RADIUS_DP * float(self._corner_scale))))
            bg.setStroke(_dp(0.5), _c(grad_stroke))
            return bg
        except Exception:
            return self._bg_rounded(_mix_hex(_with_alpha(self._accent(), 110), "#FF1A1224", 0.75), _mix_hex(_with_alpha(self._accent(), 110), "#FF4A2555", 0.45), 0.5, radius_dp=CORNER_RADIUS_DP)

    def _bg_pill(self, fill_hex: str, stroke_hex: str = "#00000000", stroke_dp: float = 0.0):
        bg = GradientDrawable()
        bg.setColor(_c(fill_hex))
        bg.setCornerRadius(float(_dp(99)))
        if stroke_dp and stroke_dp > 0:
            bg.setStroke(_dp(stroke_dp), _c(stroke_hex))
        return bg

    def _apply_rounded_clip(self, v: View):
        try:
            v.setClipToOutline(True)
            v.setOutlineProvider(ViewOutlineProvider.BACKGROUND)
        except Exception:
            pass

    def _focus_view_safe(self, v: Optional[View]):
        if v is None: return
        try: v.setFocusable(True)
        except Exception: pass
        try: v.setFocusableInTouchMode(True)
        except Exception: pass
        try: v.requestFocus()
        except Exception: pass
        try: v.requestFocusFromTouch()
        except Exception: pass

    def _set_ui_scale(self, value: Any, persist: bool = True):
        val = _clamp_ui_scale(value)
        self._ui_scale = val
        global _UI_SCALE
        _UI_SCALE = float(val)
        if persist:
            try: self.set_setting("ui_scale", f"{val:.2f}")
            except Exception: pass

    def _set_ui_pad(self, value: Any, persist: bool = True):
        val = _clamp_ui_pad(value)
        self._ui_pad = int(val)
        if persist:
            try: self.set_setting("ui_pad", str(int(val)))
            except Exception: pass

    def _set_img_preview_mode(self, mode: Any, persist: bool = True):
        m = str(mode or "compact").strip().lower()
        if m not in ("compact", "full"):
            m = "compact"
        self._img_preview_mode = m
        if persist:
            try: self.set_setting("feed_img_preview_mode", m)
            except Exception: pass

    def _set_post_img_layout_mode(self, mode: Any, persist: bool = True):
        m = str(mode or "primary").strip().lower()
        if m not in ("primary", "grid"):
            m = "primary"
        self._post_img_layout_mode = m
        if persist:
            try:
                self.set_setting("post_img_layout_mode", m)
            except Exception:
                pass

    def _apply_img_preview_mode_and_reopen(self, mode: str):
        m = str(mode or "compact").strip().lower()
        if m not in ("compact", "full"):
            m = "compact"
        if m == self._img_preview_mode: return
        self._set_img_preview_mode(m, persist=True)
        if self._overlay is None: return
        mode_now = self._mode
        fragment = get_last_fragment()
        self._suppress_open_refresh_once = True
        self._close(animated=False)
        if fragment:
            self._open(fragment)
            if mode_now != "feed": self._set_mode(mode_now)

    def _apply_post_img_layout_mode_and_reopen(self, mode: str):
        m = str(mode or "primary").strip().lower()
        if m not in ("primary", "grid"):
            m = "primary"
        if m == self._post_img_layout_mode:
            return
        self._set_post_img_layout_mode(m, persist=True)
        if self._overlay is None:
            return
        mode_now = self._mode
        fragment = get_last_fragment()
        self._suppress_open_refresh_once = True
        self._close(animated=False)
        if fragment:
            self._open(fragment)
            if mode_now != "feed":
                self._set_mode(mode_now)

    def _set_corner_scale(self, value: Any, persist: bool = True):
        val = _clamp_corner_scale(value)
        self._corner_scale = float(val)
        if persist:
            try: self.set_setting("ui_corner_scale", f"{val:.2f}")
            except Exception: pass

    def _set_accent_color(self, value: Any, persist: bool = True):
        val = _norm_accent_hex(value)
        self._accent_color = val
        if persist:
            try: self.set_setting("ui_accent", val)
            except Exception: pass

    def _accent(self) -> str:
        return str(self._accent_color or COLOR_ACCENT)

    def _reload_ui_scale_from_settings(self):
        try: raw = self.get_setting("ui_scale", f"{self._ui_scale:.2f}")
        except Exception: raw = self._ui_scale
        self._set_ui_scale(raw, persist=False)
        try: raw_pad = self.get_setting("ui_pad", str(int(self._ui_pad)))
        except Exception: raw_pad = self._ui_pad
        self._set_ui_pad(raw_pad, persist=False)
        try: raw_mode = self.get_setting("feed_img_preview_mode", self._img_preview_mode)
        except Exception: raw_mode = self._img_preview_mode
        self._set_img_preview_mode(raw_mode, persist=False)
        try: raw_post_mode = self.get_setting("post_img_layout_mode", self._post_img_layout_mode)
        except Exception: raw_post_mode = self._post_img_layout_mode
        self._set_post_img_layout_mode(raw_post_mode, persist=False)
        try:
            src_ex_raw = self.get_setting("source_exclude_filters", "")
            if src_ex_raw:
                src_arr = _safe_json_load(src_ex_raw, [])
                self._source_exclude_filters = [str(x) for x in src_arr if str(x or "").strip()]
            else:
                src_old = str(self.get_setting("source_exclude_filter", "") or "")
                self._source_exclude_filters = ([src_old] if src_old else [])
        except Exception: pass
        try:
            cat_ex_raw = self.get_setting("category_exclude_filters", "")
            if cat_ex_raw:
                cat_arr = _safe_json_load(cat_ex_raw, [])
                self._category_exclude_filters = [_norm_category(x) for x in cat_arr if _norm_category(x)]
            else:
                cat_old = _norm_category(self.get_setting("category_exclude_filter", "") or "")
                self._category_exclude_filters = ([cat_old] if cat_old else [])
        except Exception: pass
        try:
            sub_ex_raw = self.get_setting("sub_exclude_filters", "")
            sub_ex_arr = _safe_json_load(sub_ex_raw, []) if sub_ex_raw else []
            self._sub_exclude_filters = [_norm_sub(x) for x in sub_ex_arr if _norm_sub(x)]
        except Exception:
            pass
        try:
            raw_hist = self.get_setting("history_posts_limit", str(int(self._history_posts)))
        except Exception:
            raw_hist = self._history_posts
        self._history_posts = _clamp_history_posts(raw_hist)
        try: raw_corner = self.get_setting("ui_corner_scale", f"{self._corner_scale:.2f}")
        except Exception: raw_corner = self._corner_scale
        self._set_corner_scale(raw_corner, persist=False)
        try: raw_accent = self.get_setting("ui_accent", self._accent_color)
        except Exception: raw_accent = self._accent_color
        self._set_accent_color(raw_accent, persist=False)

    def _ui_scale_percent(self) -> int:
        try: return int(round(float(self._ui_scale) * 100.0))
        except Exception: return 100

    def _ui_scale_to_progress(self, value: float) -> int:
        return int(round((_clamp_ui_scale(value) - _UI_SCALE_MIN) * 100.0))

    def _progress_to_ui_scale(self, progress: int) -> float:
        return _clamp_ui_scale(_UI_SCALE_MIN + float(progress) / 100.0)

    def _apply_ui_scale_and_reopen(self, value: float):
        old = float(self._ui_scale)
        new = _clamp_ui_scale(value)
        if abs(new - old) < 0.004: return
        self._set_ui_scale(new, persist=True)
        if self._overlay is None: return
        mode_now = self._mode
        fragment = get_last_fragment()
        self._suppress_open_refresh_once = True
        self._close(animated=False)
        if fragment:
            self._open(fragment)
            if mode_now != "feed": self._set_mode(mode_now)

    def _ui_pad_to_progress(self, value: int) -> int:
        return int(_clamp_ui_pad(value) - _UI_PAD_MIN)

    def _progress_to_ui_pad(self, progress: int) -> int:
        return _clamp_ui_pad(_UI_PAD_MIN + int(progress))

    def _apply_ui_pad_and_reopen(self, value: int):
        old = int(self._ui_pad)
        new = _clamp_ui_pad(value)
        if int(new) == int(old): return
        self._set_ui_pad(new, persist=True)
        if self._overlay is None: return
        mode_now = self._mode
        fragment = get_last_fragment()
        self._suppress_open_refresh_once = True
        self._close(animated=False)
        if fragment:
            self._open(fragment)
            if mode_now != "feed": self._set_mode(mode_now)

    def _corner_scale_percent(self) -> int:
        try: return int(round(float(self._corner_scale) * 100.0))
        except Exception: return 100

    def _corner_scale_to_progress(self, value: float) -> int:
        return int(round((_clamp_corner_scale(value) - _CORNER_SCALE_MIN) * 100.0))

    def _progress_to_corner_scale(self, progress: int) -> float:
        return _clamp_corner_scale(_CORNER_SCALE_MIN + float(progress) / 100.0)

    def _apply_corner_scale_and_reopen(self, value: float):
        old = float(self._corner_scale)
        new = _clamp_corner_scale(value)
        if abs(new - old) < 0.004: return
        self._set_corner_scale(new, persist=True)
        if self._overlay is None: return
        mode_now = self._mode
        fragment = get_last_fragment()
        self._suppress_open_refresh_once = True
        self._close(animated=False)
        if fragment:
            self._open(fragment)
            if mode_now != "feed": self._set_mode(mode_now)

    def _accent_palette(self) -> List[str]:
        return [
            "#FF7E57C2", "#FF9B59B6", "#FFFF5FA2", "#FFFF6B6B", "#FFFF8C42", "#FFFFA726", "#FFFFC107", "#FF7ED957",
            "#FF2BC7B0", "#FF00BCD4", "#FF4F9DFF", "#FF3F51B5", "#FF607D8B", "#FFFFFFFF"
        ]

    def _accent_to_progress(self, color: str) -> int:
        palette = self._accent_palette()
        c = _norm_accent_hex(color)
        try:
            return palette.index(c)
        except Exception:
            return 0

    def _progress_to_accent(self, progress: int) -> str:
        palette = self._accent_palette()
        idx = max(0, min(len(palette) - 1, int(progress)))
        return palette[idx]

    def _apply_accent_and_reopen(self, color: str):
        new = _norm_accent_hex(color)
        if new == self._accent(): return
        self._set_accent_color(new, persist=True)
        if self._overlay is None:
            self._render()
            return
        mode_now = self._mode
        fragment = get_last_fragment()
        self._suppress_open_refresh_once = True
        self._close(animated=False)
        if fragment:
            self._open(fragment)
            if mode_now != "feed": self._set_mode(mode_now)

    def _set_unread_count(self, value: int, persist: bool = True):
        try: n = max(0, int(value))
        except Exception: n = 0
        self._unread_new_posts = n
        if persist:
            try: self.set_setting("rss_unread_new", str(n))
            except Exception: pass
        self._install_drawer_item()

    def _is_menu_fragment(self, fragment) -> bool:
        try:
            if fragment is None: return False
            name = str(fragment.getClass().getSimpleName() or "")
            low = name.lower()
            if "chat" in low: return False
            if "dialogs" in low or "launch" in low: return True
            return True
        except Exception:
            return False

    def _pencil_debug_tag(self, v: Optional[View]) -> str:
        if v is None: return "<none>"
        try: cls = str(v.getClass().getSimpleName() or "View")
        except Exception: cls = "View"
        parts = [cls]
        try:
            rid = int(v.getId())
            if rid > 0:
                try:
                    name = str(v.getResources().getResourceEntryName(rid) or "")
                    if name: parts.append(f"id={name}")
                except Exception:
                    parts.append(f"id#{rid}")
        except Exception:
            pass

    def _apply_history_limit(self, value: Any):
        try:
            val = _clamp_history_posts(value)
            self._history_posts = val
            try: self.set_setting("history_posts_limit", str(val))
            except Exception: pass
            self._render()
        except Exception:
            pass
        try:
            desc = str(v.getContentDescription() or "").strip()
            if desc: parts.append(f"desc='{desc}'")
        except Exception:
            pass
        try:
            x = int(v.getLeft()); y = int(v.getTop()); w = int(v.getWidth()); h = int(v.getHeight())
            parts.append(f"xywh={x},{y},{w},{h}")
        except Exception:
            pass
        return " ".join(parts)

    def _looks_like_pencil_action(self, v: View, root_w: int, root_h: int) -> bool:
        try:
            if v is None: return False
            w = int(v.getWidth()); h = int(v.getHeight())
            if w <= 0 or h <= 0: return False
            x = int(v.getLeft()); y = int(v.getTop())
            if root_w > 0 and (x + w) < int(root_w * 0.65): return False
            if root_h > 0 and y < int(root_h * 0.45): return False
            text = ""
            try: text += " " + str(v.getContentDescription() or "")
            except Exception: pass
            try: text += " " + str(v.getClass().getSimpleName() or "")
            except Exception: pass
            try:
                rid = int(v.getId())
                if rid > 0:
                    try: text += " " + str(v.getResources().getResourceEntryName(rid) or "")
                    except Exception: pass
            except Exception:
                pass
            low = text.lower()
            keys = ("pencil", "compose", "new", "create", "write", "edit", "floating", "fab", "message", "карандаш", "создать", "напис")
            if any(k in low for k in keys): return True
            return bool(isinstance(v, ImageView) and min(w, h) >= _dp(36) and max(w, h) <= _dp(90))
        except Exception:
            return False

    def _find_pencil_view_from_fragment(self, fragment) -> Optional[View]:
        try:
            if fragment is None or get_private_field is None:
                return None
            keys = ("floatingButtonContainer", "floatingButton2Container", "floatingButton")
            for key in keys:
                try:
                    v = get_private_field(fragment, key)
                except Exception:
                    v = None
                if isinstance(v, View):
                    log(f"[RSS] pencil hook field hit: {key} -> {self._pencil_debug_tag(v)}")
                    return v
            log("[RSS] pencil hook field scan: no floating button fields")
            return None
        except Exception as e:
            log(f"[RSS] pencil hook field scan error: {e}")
            return None

    def _find_pencil_view(self, root) -> Optional[View]:
        try:
            if not isinstance(root, ViewGroup): return None
            rw = int(root.getWidth()); rh = int(root.getHeight())
            stack = [root]
            candidates = []
            while stack:
                cur = stack.pop()
                if isinstance(cur, ViewGroup):
                    try: cnt = int(cur.getChildCount())
                    except Exception: cnt = 0
                    for i in range(cnt):
                        try: stack.append(cur.getChildAt(i))
                        except Exception: pass
                if cur is root: continue
                try:
                    if int(cur.getVisibility()) != int(View.VISIBLE):
                        continue
                except Exception:
                    pass
                if self._looks_like_pencil_action(cur, rw, rh):
                    candidates.append(cur)
            if not candidates:
                log("[RSS] pencil hook: no candidates found")
                return None
            try:
                candidates.sort(key=lambda v: (-(int(v.getLeft()) + int(v.getWidth())), -(int(v.getTop()) + int(v.getHeight())), -int(v.getWidth()) * int(v.getHeight())))
            except Exception:
                pass
            top = candidates[0]
            for i, c in enumerate(candidates[:5]):
                log(f"[RSS] pencil hook candidate[{i}]: {self._pencil_debug_tag(c)}")
            return top
        except Exception as e:
            log(f"[RSS] pencil hook find error: {e}")
            return None

    def _install_pencil_hook_view_trigger(self):
        try:
            if self._pencil_hook_view is not None:
                return
            fragment = get_last_fragment()
            if not self._is_menu_fragment(fragment):
                return
            activity = fragment.getParentActivity()
            if not activity: return
            decor = activity.getWindow().getDecorView()
            if not isinstance(decor, ViewGroup): return

            pencil = self._find_pencil_view_from_fragment(fragment)
            if pencil is None:
                pencil = self._find_pencil_view(decor)
            if pencil is None:
                log("[RSS] pencil hook: target view not found")
                return

            try:
                frag_name = str(fragment.getClass().getSimpleName() or "")
            except Exception:
                frag_name = ""
            log(f"[RSS] pencil hook attached ({frag_name}): {self._pencil_debug_tag(pencil)}")

            def on_touch(_v, ev):
                try:
                    raw_act = int(ev.getAction())
                    try: act = int(ev.getActionMasked())
                    except Exception: act = raw_act
                except Exception:
                    return False
                if act == int(MotionEvent.ACTION_DOWN):
                    self._pencil_press_armed = True
                    self._pencil_touch_token += 1
                    token = int(self._pencil_touch_token)
                    try:
                        self._pencil_down_x = float(ev.getRawX())
                        self._pencil_down_y = float(ev.getRawY())
                    except Exception:
                        self._pencil_down_x = 0.0
                        self._pencil_down_y = 0.0
                    try:
                        self._pencil_touch_slop = int(ViewConfiguration.get(pencil.getContext()).getScaledTouchSlop())
                    except Exception:
                        self._pencil_touch_slop = _dp(12)
                    log(f"[RSS] pencil hold: ACTION_DOWN armed slop={self._pencil_touch_slop}")
                    def trigger():
                        try:
                            if token != int(self._pencil_touch_token): return
                            if not self._pencil_press_armed: return
                            frag = get_last_fragment()
                            if not self._is_menu_fragment(frag): return
                            self._pencil_press_armed = False
                            log("[RSS] pencil hold: 500ms trigger fired")
                            try: pencil.performHapticFeedback(HapticFeedbackConstants.KEYBOARD_TAP)
                            except Exception: pass
                            self._open(frag)
                        except Exception as e:
                            log(f"[RSS] pencil hold trigger error: {e}")
                    try: AndroidUtilities.runOnUIThread(Runnable(trigger), 500)
                    except Exception: pass
                    return False
                if act == int(MotionEvent.ACTION_MOVE):
                    try:
                        dx = abs(float(ev.getRawX()) - float(self._pencil_down_x))
                        dy = abs(float(ev.getRawY()) - float(self._pencil_down_y))
                        sl = max(1, int(self._pencil_touch_slop or 0))
                        if dx > sl or dy > sl:
                            if self._pencil_press_armed:
                                log(f"[RSS] pencil hold: disarm move dx={dx:.1f} dy={dy:.1f} slop={sl}")
                            self._pencil_press_armed = False
                    except Exception:
                        pass
                    return False
                # На некоторых сборках прилетает ранний CANCEL во время удержания FAB,
                # поэтому разоружаем только по явному UP (masked/raw).
                up_codes = {int(MotionEvent.ACTION_UP)}
                try:
                    up_codes.add(int(MotionEvent.ACTION_POINTER_UP))
                except Exception:
                    pass
                if act in up_codes or raw_act in up_codes:
                    if self._pencil_press_armed:
                        log(f"[RSS] pencil hold: disarm up action={act} raw={raw_act}")
                    self._pencil_press_armed = False
                    return False
                return False

            try:
                self._pencil_touch_listener = _OnTouchListener(on_touch)
                pencil.setOnTouchListener(self._pencil_touch_listener)
                def on_long_click(_v):
                    try:
                        frag = get_last_fragment()
                        if not self._is_menu_fragment(frag):
                            return False
                        self._pencil_press_armed = False
                        log("[RSS] pencil hold: native onLongClick fired")
                        try: pencil.performHapticFeedback(HapticFeedbackConstants.LONG_PRESS)
                        except Exception: pass
                        self._open(frag)
                        return True
                    except Exception as e:
                        log(f"[RSS] pencil onLongClick error: {e}")
                        return False
                self._pencil_long_click_listener = _OnLongClickListener(on_long_click)
                try:
                    pencil.setLongClickable(True)
                except Exception:
                    pass
                pencil.setOnLongClickListener(self._pencil_long_click_listener)
                self._pencil_hook_view = pencil
            except Exception as e:
                log(f"[RSS] pencil hook attach listener error: {e}")
        except Exception as e:
            log(f"[RSS] pencil hook install error: {e}")

    def _remove_pencil_hook_view_trigger(self):
        h = self._pencil_hook_view
        if h is None: return
        try:
            h.setOnTouchListener(None)
        except Exception:
            pass
        try:
            h.setOnLongClickListener(None)
        except Exception:
            pass
        log(f"[RSS] pencil hook detached: {self._pencil_debug_tag(h)}")
        self._pencil_hook_view = None
        self._pencil_touch_listener = None
        self._pencil_long_click_listener = None
        self._pencil_press_armed = False
        self._pencil_down_x = 0.0
        self._pencil_down_y = 0.0
        self._pencil_touch_slop = 0

    # ---------- lifecycle ----------
    def on_plugin_load(self):
        self._reload_ui_scale_from_settings()
        try: self._unread_new_posts = max(0, int(self.get_setting("rss_unread_new", "0") or 0))
        except Exception: self._unread_new_posts = 0
        self._install_drawer_item()
        run_on_ui_thread(self._install_pencil_hook_view_trigger)
        self._bg_thread_running = True
        threading.Thread(target=self._bg_worker, daemon=True).start()

    def on_plugin_unload(self):
        self._bg_thread_running = False
        run_on_ui_thread(lambda: self._close(animated=False))
        run_on_ui_thread(lambda: self._close_add_feed_screen(animated=False))
        run_on_ui_thread(lambda: self._close_category_screen(animated=False))
        run_on_ui_thread(lambda: self._close_source_picker_screen(animated=False))
        run_on_ui_thread(lambda: self._close_post_screen(animated=False))
        run_on_ui_thread(lambda: self._close_image_screen(animated=False))
        run_on_ui_thread(lambda: self._close_mini_overlay(animated=False))
        run_on_ui_thread(self._remove_pencil_hook_view_trigger)

    # ---------- bg worker ----------
    def _bg_worker(self):
        warmup = 20
        while self._bg_thread_running:
            step = warmup
            warmup = 0
            if step <= 0:
                try:
                    raw_sec = self.get_setting("bg_refresh_seconds", None)
                    if raw_sec is None:
                        raw_min = self.get_setting("bg_refresh_minutes", "3")
                        raw_sec = int(round(float(raw_min) * 60.0))
                    step = _clamp_bg_refresh_seconds(raw_sec)
                except Exception:
                    step = 180
            for _ in range(step):
                if not self._bg_thread_running: return
                time.sleep(1)
            if not self.get_setting("auto_refresh", True):
                continue
            try:
                self._silent_refresh_check()
            except Exception as e:
                log(f"[RSS] bg worker error: {e}")

    def _silent_refresh_check(self):
        old_cache = self._get_cache()
        old_keys = set(str(x.get("tg_post_id") or x.get("link") or "") for x in old_cache)
        with self._refresh_lock:
            self._refresh_now()
        new_cache = self._get_cache()
        new_keys = set(str(x.get("tg_post_id") or x.get("link") or "") for x in new_cache)
        diff = {k for k in (new_keys - old_keys) if k}
        if diff:
            if self._overlay is None:
                self._set_unread_count(self._unread_new_posts + len(diff), persist=True)
            else:
                self._set_unread_count(0, persist=True)
            def show_toast():
                try: Toast.makeText(ApplicationLoader.applicationContext, _tr(f"ExteraRSS: {len(diff)} новых постов!", f"ExteraRSS: {len(diff)} new posts!"), Toast.LENGTH_LONG).show()
                except Exception: pass
            run_on_ui_thread(show_toast)
            if self._overlay is not None and self._list_container is not None:
                run_on_ui_thread(self._render)

    # ---------- settings ----------
    def _clear_cache(self):
        try:
            self.set_setting("rss_cache", "[]")
            self.set_setting("rss_cache_ts", "0")
        except Exception: pass
        try: run_on_ui_thread(self._render)
        except Exception: pass

    def create_settings(self):
        return [
            Header(text=_tr("RSS Моя лента", "RSS My Feed")),
            Text(text=_tr("Открыть ленту", "Open feed"), icon="msg_list", accent=True, on_click=lambda v: self._open(get_last_fragment())),
            Text(text=_tr("Очистить кэш", "Clear cache"), icon="msg_delete", accent=False, on_click=lambda v: self._clear_cache()),
            Divider(),
            Switch(key="auto_refresh", text=_tr("Автообновление (и уведомления в фоне)", "Auto-refresh (and background notifications)"), default=True, icon="msg_autodelete"),
            Text(text=_tr("Фон-проверка: ~каждые 3 мин", "Background check: ~every 3 min"), icon="msg_clock", accent=False),
        ]

    # ---------- drawer ----------
    def _install_drawer_item(self):
        try:
            unread = max(0, int(self._unread_new_posts))
            base = _tr("Моя лента", "My Feed")
            txt = (f"{base} +{unread}") if unread > 0 else base
            item = MenuItemData(menu_type=MenuItemType.DRAWER_MENU, text=txt, on_click=lambda ctx: self._open(ctx.get("fragment") or get_last_fragment()), icon="msg_list", item_id="rss_my_feed_drawer", subtext="RSS/Atom + Telegram", priority=980)
            self.add_menu_item(item)
        except Exception: pass

    # ---------- storage ----------
    def _get_sub_entries(self) -> List[Dict[str, str]]:
        raw = self.get_setting("rss_subs", "[]")
        subs = _safe_json_load(raw, [])
        if not isinstance(subs, list): return []
        out: List[Dict[str, str]] = []
        seen = {}
        for it in subs:
            sub = ""
            cat = ""
            if isinstance(it, dict):
                sub = _norm_sub(str(it.get("sub") or it.get("url") or it.get("source") or ""))
                cat = _norm_category(it.get("category") or it.get("cat") or "")
            else: sub = _norm_sub(str(it))
            if not sub: continue
            if sub in seen:
                idx = seen[sub]
                if cat and not out[idx].get("category"): out[idx]["category"] = cat
                continue
            seen[sub] = len(out)
            out.append({"sub": sub, "category": cat})
        return out

    def _set_sub_entries(self, entries: List[Dict[str, Any]]):
        try:
            out: List[Dict[str, str]] = []
            seen = set()
            for it in entries:
                if not isinstance(it, dict): continue
                sub = _norm_sub(str(it.get("sub") or ""))
                if not sub or sub in seen: continue
                seen.add(sub)
                out.append({"sub": sub, "category": _norm_category(it.get("category") or "")})
            self.set_setting("rss_subs", json.dumps(out, ensure_ascii=False))
        except Exception: pass

    def _get_cache(self) -> List[Dict[str, Any]]:
        raw = self.get_setting("rss_cache", "[]")
        arr = _safe_json_load(raw, [])
        if not isinstance(arr, list): return []
        out: List[Dict[str, Any]] = []
        for it in arr:
            if not isinstance(it, dict): continue
            link = str(it.get("link", "") or "")
            title = str(it.get("title", "") or "")
            if link:
                images = _norm_images_list(it.get("images", []))
                if not images:
                    one = _upgrade_image_url(it.get("image", ""))
                    if one: images = [one]
                out.append({"source_handle": str(it.get("source_handle", "") or ""), "source_title": str(it.get("source_title", "") or ""), "title": title, "link": link, "published_raw": str(it.get("published_raw", "") or ""), "ts": int(it.get("ts", 0) or 0), "fetched_ts": int(it.get("fetched_ts", 0) or 0), "sort_ts": int(it.get("sort_ts", 0) or 0), "source": str(it.get("source", "") or ""), "text": str(it.get("text", "") or ""), "image": (images[0] if images else ""), "images": images, "reply": str(it.get("reply", "") or ""), "doc": str(it.get("doc", "") or ""), "voice": str(it.get("voice", "") or ""), "tg_post_id": str(it.get("tg_post_id", "") or ""), "category": _norm_category(it.get("category", ""))})
        return out

    def _set_cache(self, items: List[Dict[str, Any]]):
        try:
            self.set_setting("rss_cache", json.dumps(items, ensure_ascii=False))
            self.set_setting("rss_cache_ts", str(_now_ts()))
        except Exception: pass

    # ---------- refresh / gesture handlers ----------
    def _handle_global_touch(self, v, ev) -> bool:
        try:
            try: act = int(ev.getActionMasked())
            except Exception: act = int(ev.getAction())
            x = float(ev.getRawX())
            y = float(ev.getRawY())
            if act == MotionEvent.ACTION_DOWN:
                self._gesture_start_x = x
                self._gesture_start_y = y
                self._gesture_switched = False
                try: at_top = (self._main_scroll.getScrollY() <= 0)
                except Exception: at_top = False
                self._pull_armed = (self._mode in ("feed", "cats") and (not self._refreshing) and at_top)
                return False
            if act == MotionEvent.ACTION_MOVE:
                dx = x - self._gesture_start_x
                dy = y - self._gesture_start_y
                if (not self._gesture_switched) and (abs(dx) > float(_dp(72))) and (abs(dx) > abs(dy) * 1.2):
                    self._gesture_switched = True
                    self._pull_armed = False
                    self._switch_mode_by_swipe(dx)
                    return True
                if self._pull_armed and self._mode in ("feed", "cats") and not self._refreshing:
                    try: at_top = (self._main_scroll.getScrollY() <= 0)
                    except Exception: at_top = False
                    if not at_top: self._pull_armed = False
                    elif dy > float(_dp(80)) and dy > abs(dx):
                        self._pull_armed = False
                        self._gesture_switched = True
                        try: self._main_scroll.performHapticFeedback(HapticFeedbackConstants.KEYBOARD_TAP)
                        except Exception: pass
                        self._set_refreshing_ui(True)
                        self._refresh_async()
                        return True
                return bool(self._gesture_switched)
            if act in (MotionEvent.ACTION_UP, MotionEvent.ACTION_CANCEL):
                self._pull_armed = False
                self._gesture_switched = False
                return False
        except Exception: return False
        return False

    def _bind_back_handler(self, overlay: View, close_cb, store_attr: str):
        try:
            self._focus_view_safe(overlay)
            def on_key(_v, key_code, event):
                try:
                    if bool(getattr(self, "_back_tracking_paused", False)): return False
                    if int(key_code) != int(KeyEvent.KEYCODE_BACK): return False
                    act = int(event.getAction())
                    if act == int(KeyEvent.ACTION_DOWN): close_cb(); return True
                    if act == int(KeyEvent.ACTION_UP): return True
                    return False
                except Exception: return False
            listener = None
            try: listener = _OnKeyListener(on_key)
            except Exception:
                class _LocalOnKeyListener(dynamic_proxy(View.OnKeyListener)):
                    def __init__(self, fn):
                        super().__init__()
                        self._fn = fn
                    def onKey(self, v, key_code, event): return bool(self._fn(v, key_code, event))
                listener = _LocalOnKeyListener(on_key)
            def attach_to_tree(v: View):
                try: v.setOnKeyListener(listener)
                except Exception: pass
                if isinstance(v, ViewGroup):
                    try: cnt = int(v.getChildCount() or 0)
                    except Exception: cnt = 0
                    for i in range(cnt):
                        try: ch = v.getChildAt(i)
                        except Exception: ch = None
                        if ch is not None: attach_to_tree(ch)
            attach_to_tree(overlay)
            self._focus_view_safe(overlay)
            def late_bind():
                try: attach_to_tree(overlay); self._focus_view_safe(overlay)
                except Exception: pass
            def focus_guard():
                try:
                    if overlay.getParent() is None: return
                except Exception: return
                try: attach_to_tree(overlay); self._focus_view_safe(overlay)
                except Exception: pass
                try: AndroidUtilities.runOnUIThread(Runnable(focus_guard), 420)
                except Exception: pass
            try:
                AndroidUtilities.runOnUIThread(Runnable(late_bind), 80)
                AndroidUtilities.runOnUIThread(Runnable(late_bind), 220)
                AndroidUtilities.runOnUIThread(Runnable(focus_guard), 420)
            except Exception: pass
            setattr(self, store_attr, listener)
        except Exception: pass

    def _handle_back_action(self) -> bool:
        try:
            if self._mini_overlay is not None: self._restore_from_mini(); return True
            if self._img_overlay is not None: self._close_image_screen(animated=True); return True
            if self._post_overlay is not None: self._close_post_screen(animated=True); return True
            if self._src_overlay is not None: self._close_source_picker_screen(animated=True); return True
            if self._cat_overlay is not None: self._close_category_screen(animated=True); return True
            if self._add_overlay is not None: self._close_add_feed_screen(animated=True); return True
            if self._overlay is not None: self._close(animated=True); return True
        except Exception: pass
        return False

    def _set_refreshing_ui(self, val: bool):
        self._refreshing = bool(val)
        self._refresh_fade_token += 1
        token = int(self._refresh_fade_token)
        try:
            rb = self._refresh_bar
            if rb is None: return
            if val:
                rb.setVisibility(View.VISIBLE)
                rb.setAlpha(0.0)
                rb.setTranslationY(float(_dp(-30)))
                rb.animate().alpha(1.0).translationY(0.0).setDuration(250).setInterpolator(OvershootInterpolator(1.0)).start()
                def late_fade():
                    try:
                        if int(self._refresh_fade_token) != token: return
                        if not self._refreshing: return
                        rb.animate().alpha(0.58).setDuration(260).start()
                    except Exception:
                        pass
                try: AndroidUtilities.runOnUIThread(Runnable(late_fade), 2000)
                except Exception: pass
            else:
                anim = rb.animate().alpha(0.0).translationY(float(_dp(-30))).setDuration(200)
                anim.withEndAction(Runnable(lambda: rb.setVisibility(View.GONE)))
                anim.start()
        except Exception: pass

    def _source_filter_label(self) -> str:
        if not self._source_filter: return _tr("Все источники ▾", "All sources ▾")
        name = self._source_filter
        if len(name) > 16: name = name[:15].rstrip() + "…"
        return f"{name} ▾"

    def _category_filter_label(self) -> str:
        if not self._category_filter: return _tr("Все категории ▾", "All categories ▾")
        name = self._category_filter
        if len(name) > 16: name = name[:15].rstrip() + "…"
        return f"{name} ▾"

    def _top_filter_label(self) -> str:
        if self._mode == "settings": return _tr("Настройки", "Settings")
        if self._mode == "subs": return _tr("Управление", "Manage")
        return self._category_filter_label() if self._mode == "cats" else self._source_filter_label()

    def _update_source_button(self):
        try:
            if self._source_btn is not None:
                self._source_btn.setText(self._top_filter_label())
                self._source_btn.setAlpha(0.6 if self._mode in ("settings", "subs") else 1.0)
        except Exception: pass

    def _available_sources(self) -> List[str]:
        vals = []
        for it in self._get_cache():
            s = _format_source_line(it).strip()
            if not s: s = str(it.get("source", "") or "").strip()
            if s: vals.append(s)
        return _uniq_keep_order(vals)

    def _source_filter_options(self) -> List[str]:
        return [""] + self._available_sources()

    def _sub_exclude_options(self) -> List[str]:
        vals = []
        for it in self._get_sub_entries():
            sub = _norm_sub(str(it.get("sub") or ""))
            if sub:
                vals.append(sub)
        return _uniq_keep_order(vals)

    def _available_categories(self) -> List[str]:
        vals = []
        for it in self._get_cache():
            c = _norm_category(it.get("category", ""))
            if c: vals.append(c)
        for it in self._get_sub_entries():
            c = _norm_category(it.get("category", ""))
            if c: vals.append(c)
        return _uniq_keep_order(vals)

    def _category_filter_options(self) -> List[str]:
        return [""] + self._available_categories()

    def _set_source_filter(self, source_value: str):
        val = str(source_value or "")
        opts = self._source_filter_options()
        self._source_filter = val if val in opts else ""
        self._source_exclude_filters = []
        try:
            self.set_setting("source_exclude_filter", "")
            self.set_setting("source_exclude_filters", "[]")
        except Exception: pass
        self._update_source_button()
        self._animate_list_once = False
        self._render()

    def _set_category_filter(self, category_value: str):
        val = _norm_category(category_value)
        opts = self._category_filter_options()
        self._category_filter = val if val in opts else ""
        self._category_exclude_filters = []
        try:
            self.set_setting("category_exclude_filter", "")
            self.set_setting("category_exclude_filters", "[]")
        except Exception: pass
        self._update_source_button()
        self._animate_list_once = False
        self._render()

    def _set_source_exclude_filter(self, source_value: str) -> bool:
        val = str(source_value or "")
        opts = self._source_filter_options()
        if val not in opts or not val:
            return False
        arr = list(self._source_exclude_filters)
        if val in arr:
            arr = [x for x in arr if x != val]
            is_excluded = False
        else:
            arr.append(val)
            is_excluded = True
        self._source_exclude_filters = _uniq_keep_order(arr)
        self._source_filter = ""
        try:
            self.set_setting("source_exclude_filter", "")
            self.set_setting("source_exclude_filters", json.dumps(self._source_exclude_filters, ensure_ascii=False))
        except Exception: pass
        self._update_source_button()
        self._animate_list_once = False
        self._render()
        return is_excluded

    def _set_category_exclude_filter(self, category_value: str) -> bool:
        val = _norm_category(category_value)
        opts = self._category_filter_options()
        if val not in opts or not val:
            return False
        arr = list(self._category_exclude_filters)
        if val in arr:
            arr = [x for x in arr if x != val]
            is_excluded = False
        else:
            arr.append(val)
            is_excluded = True
        self._category_exclude_filters = _uniq_keep_order(arr)
        self._category_filter = ""
        try:
            self.set_setting("category_exclude_filter", "")
            self.set_setting("category_exclude_filters", json.dumps(self._category_exclude_filters, ensure_ascii=False))
        except Exception: pass
        self._update_source_button()
        self._animate_list_once = False
        self._render()
        return is_excluded

    def _toggle_sub_exclude_filter(self, sub_key: str) -> bool:
        val = _norm_sub(sub_key)
        if not val:
            return False
        arr = list(self._sub_exclude_filters)
        if val in arr:
            arr = [x for x in arr if x != val]
            is_excluded = False
        else:
            arr.append(val)
            is_excluded = True
        self._sub_exclude_filters = _uniq_keep_order(arr)
        try:
            self.set_setting("sub_exclude_filters", json.dumps(self._sub_exclude_filters, ensure_ascii=False))
        except Exception:
            pass
        self._render()
        return is_excluded

    def _is_item_blocked_by_sub_exclude(self, it: Dict[str, Any]) -> bool:
        try:
            blocked = set(self._sub_exclude_filters or [])
            if not blocked:
                return False
            src_handle = str(it.get("source_handle", "") or "").strip()
            src = str(it.get("source", "") or "").strip()
            if src_handle.startswith("@"):
                if _norm_sub("tguser:" + src_handle[1:]) in blocked:
                    return True
            if src and _norm_sub(src) in blocked:
                return True
        except Exception:
            return False
        return False

    def _open_top_filter_picker(self):
        if self._mode in ("settings", "subs"): return
        if self._mode == "cats": self._open_category_picker_screen()
        else: self._open_source_picker_screen()

    def _open_picker_screen(self, picker_title: str, options: List[Tuple[str, str]], current_value: str, on_select, on_long_select=None, excluded_values: Optional[List[str]] = None):
        if self._src_overlay is not None: return
        fragment = get_last_fragment()
        if not fragment: return
        activity = fragment.getParentActivity()
        if not activity: return
        decor = activity.getWindow().getDecorView()
        if not isinstance(decor, ViewGroup): return

        overlay = FrameLayout(activity)
        overlay.setLayoutParams(FrameLayout.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.MATCH_PARENT))
        overlay.setBackgroundColor(_c(COLOR_OVERLAY)) 
        overlay.setClickable(True)
        overlay.setFocusable(True)
        overlay.setOnClickListener(OnClickListener(lambda _v: self._close_source_picker_screen(animated=True)))

        card = LinearLayout(activity)
        card.setOrientation(LinearLayout.VERTICAL)
        card.setPadding(_dp(16), _dp(20), _dp(16), _dp(16))
        card.setBackground(self._bg_rounded(COLOR_CARD, COLOR_STROKE, stroke_dp=1, radius_dp=24))
        card.setClickable(True)
        lp_card = FrameLayout.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.WRAP_CONTENT)
        lp_card.leftMargin = _dp(16)
        lp_card.rightMargin = _dp(16)
        lp_card.topMargin = _statusbar_pad() + _dp(80)
        overlay.addView(card, lp_card)

        title_tv = TextView(activity)
        title_tv.setText(picker_title)
        title_tv.setTextSize(22)
        title_tv.setTypeface(None, Typeface.BOLD)
        title_tv.setTextColor(_c(COLOR_TEXT_PR))
        title_tv.setPadding(_dp(8), 0, _dp(8), _dp(8))
        card.addView(title_tv)

        hint_tv = TextView(activity)
        hint_tv.setText(_tr("Долгое нажатие: исключить", "Long press: exclude"))
        hint_tv.setTextSize(12)
        hint_tv.setTextColor(_c(COLOR_TEXT_SEC))
        hint_tv.setPadding(_dp(8), 0, _dp(8), _dp(12))
        card.addView(hint_tv)

        sv = ScrollView(activity)
        sv.setLayoutParams(LinearLayout.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.WRAP_CONTENT))
        card.addView(sv)

        col = LinearLayout(activity)
        col.setOrientation(LinearLayout.VERTICAL)
        sv.addView(col)

        current = str(current_value or "")
        for value, label in options:
            btn = TextView(activity)
            btn.setText(label)
            btn.setTextSize(15)
            btn.setTextColor(_c(COLOR_TEXT_PR))
            btn.setPadding(_dp(16), _dp(14), _dp(16), _dp(14))
            btn.setClickable(True)
            excluded_set = set(str(x) for x in (excluded_values or []))
            selected = (value == current)
            excluded = (value in excluded_set and bool(value))
            btn.setAlpha(1.0 if (selected or excluded) else 0.8)
            if excluded:
                btn.setTextColor(_c("#FFFF6B6B"))
                btn.setBackground(self._bg_rounded("#22FF6B6B", "#66FF6B6B", stroke_dp=1, radius_dp=16))
            else:
                btn.setTextColor(_c(COLOR_TEXT_PR))
                btn.setBackground(self._bg_rounded(self._accent() if selected else "#08FFFFFF", radius_dp=16))
            
            def make_on_select(v_val):
                def _click(_v):
                    self._bounce_anim(_v)
                    try:
                        on_select(v_val)
                        self._close_source_picker_screen(animated=True)
                    except Exception: pass
                return _click

            btn.setOnClickListener(OnClickListener(make_on_select(value)))

            if on_long_select is not None and value:
                def make_on_long(v_val):
                    def _long(_v):
                        self._bounce_anim(_v)
                        try:
                            is_now_excluded = bool(on_long_select(v_val))
                            if is_now_excluded:
                                _v.setTextColor(_c("#FFFF6B6B"))
                                _v.setBackground(self._bg_rounded("#22FF6B6B", "#66FF6B6B", stroke_dp=1, radius_dp=16))
                            else:
                                _v.setTextColor(_c(COLOR_TEXT_PR))
                                _v.setBackground(self._bg_rounded("#08FFFFFF", radius_dp=16))
                            return True
                        except Exception:
                            return False
                    return _long
                try: btn.setOnLongClickListener(_OnLongClickListener(make_on_long(value)))
                except Exception: pass

            lp_btn = LinearLayout.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.WRAP_CONTENT)
            lp_btn.bottomMargin = _dp(8)
            col.addView(btn, lp_btn)

        close_btn = self._top_button(activity, " Отмена ", lambda: self._close_source_picker_screen(animated=True))
        lp_close = LinearLayout.LayoutParams(ViewGroup.LayoutParams.WRAP_CONTENT, ViewGroup.LayoutParams.WRAP_CONTENT)
        lp_close.topMargin = _dp(12)
        lp_close.gravity = Gravity.END
        card.addView(close_btn, lp_close)

        self._src_overlay = overlay
        self._src_content = card
        decor.addView(overlay)
        self._bind_back_handler(overlay, lambda: self._handle_back_action(), "_src_back_listener")
        self._slide_up_enter(overlay, card)

    def _open_source_picker_screen(self):
        vals = self._source_filter_options()
        options = [("", _tr("Все источники", "All sources"))] + [(x, x) for x in vals if x]
        cur = self._source_filter if self._source_filter in vals else ""
        self._open_picker_screen(_tr("Выбор источника", "Select source"), options, cur, self._set_source_filter, self._set_source_exclude_filter, self._source_exclude_filters)

    def _open_category_picker_screen(self):
        vals = self._category_filter_options()
        options = [("", _tr("Все категории", "All categories"))] + [(x, x) for x in vals if x]
        cur = self._category_filter if self._category_filter in vals else ""
        self._open_picker_screen(_tr("Выбор категории", "Select category"), options, cur, self._set_category_filter, self._set_category_exclude_filter, self._category_exclude_filters)

    def _close_source_picker_screen(self, animated: bool):
        overlay = self._src_overlay
        content = self._src_content
        if overlay is None: return
        def detach():
            try:
                parent = overlay.getParent()
                if parent and isinstance(parent, ViewGroup): parent.removeView(overlay)
            except Exception: pass
            self._src_overlay = None; self._src_content = None; self._src_back_listener = None
        if not animated or content is None: detach(); return
        self._slide_down_exit(overlay, content)
        try: AndroidUtilities.runOnUIThread(Runnable(detach), 200)
        except Exception: run_on_ui_thread(detach)

    def _refresh_now(self):
        sub_entries = self._get_sub_entries()
        active_subs = {_norm_sub(str(x.get("sub") or "")) for x in sub_entries if _norm_sub(str(x.get("sub") or ""))}
        old = self._get_cache()
        old_by_key = {}
        for x in old:
            if not isinstance(x, dict): continue
            key = str(x.get("tg_post_id") or x.get("link") or "")
            if key: old_by_key[key] = x

        fetched_now = _now_ts()
        all_items: List[Dict[str, Any]] = []

        for sub_item in sub_entries:
            sub = str(sub_item.get("sub") or "")
            sub_cat = _norm_category(sub_item.get("category") or "")
            if not sub: continue
            try:
                if sub.startswith("tguser:"):
                    username = sub.split(":", 1)[1].strip()
                    if not username: continue
                    src_title, items = _fetch_tg_user_feed(username)
                else:
                    xml = _http_get(sub, timeout_sec=12)
                    src_title, items = parse_feed(xml, sub)

                for it in items[:250]:
                    key = str(it.get("tg_post_id") or it.get("link") or "")
                    it["source"] = it.get("source") or src_title or sub
                    it["fetched_ts"] = fetched_now
                    it["source_handle"] = str(it.get("source_handle", "") or "")
                    it["source_title"]  = str(it.get("source_title", "") or it.get("source", "") or "")
                    it["reply"] = str(it.get("reply", "") or "")
                    it["doc"] = str(it.get("doc", "") or "")
                    it["voice"] = str(it.get("voice", "") or "")
                    it["tg_post_id"] = str(it.get("tg_post_id", "") or "")
                    imgs = _norm_images_list(it.get("images", []))
                    one_img = _upgrade_image_url(it.get("image", ""))
                    if one_img and one_img not in imgs: imgs.insert(0, one_img)
                    it["images"] = imgs
                    it["image"] = imgs[0] if imgs else one_img
                    prev = old_by_key.get(key) if key else None
                    prev_cat = _norm_category((prev or {}).get("category") or "")
                    it["category"] = sub_cat if sub_cat else prev_cat
                    ts = int(it.get("ts", 0) or 0)
                    if ts > 0: it["sort_ts"] = ts
                    else:
                        prev_sort = int((prev or {}).get("sort_ts", 0) or 0)
                        it["sort_ts"] = prev_sort if prev_sort > 0 else fetched_now
                all_items.extend(items[:250])
            except Exception: pass

        seen = set()
        uniq = []
        for it in all_items:
            key = str(it.get("tg_post_id") or it.get("link") or "")
            if not key or key in seen: continue
            seen.add(key)
            uniq.append(it)

        if active_subs:
            for old_it in old:
                if not isinstance(old_it, dict):
                    continue
                src_handle = str(old_it.get("source_handle", "") or "").strip()
                src = str(old_it.get("source", "") or "").strip()
                keep = False
                if src_handle and src_handle.startswith("@"):
                    tg_sub = _norm_sub("tguser:" + src_handle[1:])
                    if tg_sub in active_subs:
                        keep = True
                if (not keep) and src:
                    if _norm_sub(src) in active_subs:
                        keep = True
                if not keep:
                    continue
                key = str(old_it.get("tg_post_id") or old_it.get("link") or "")
                if not key or key in seen:
                    continue
                seen.add(key)
                uniq.append(old_it)

        uniq.sort(key=lambda x: int(x.get("sort_ts", x.get("ts", 0) or 0) or 0), reverse=True)
        self._set_cache(uniq[:900])

    def _refresh_async(self):
        def bg():
            try:
                with self._refresh_lock: self._refresh_now()
            finally:
                def ui():
                    self._set_refreshing_ui(False)
                    self._render()
                    self._update_source_button()
                run_on_ui_thread(ui)
        threading.Thread(target=bg, daemon=True).start()

    # ---------- UI Formats ----------
    def _reply_bubble(self, ctx, reply_text: str) -> View:
        row = LinearLayout(ctx)
        row.setOrientation(LinearLayout.HORIZONTAL)
        row.setPadding(_dp(12), _dp(10), _dp(12), _dp(10))
        row.setBackground(self._bg_rounded("#1AFFFFFF", radius_dp=12))

        bar = View(ctx)
        gd = GradientDrawable()
        gd.setColor(_c(self._accent()))
        gd.setCornerRadius(_dp(99))
        bar.setBackground(gd)

        lp_bar = LinearLayout.LayoutParams(_dp(3), ViewGroup.LayoutParams.MATCH_PARENT)
        row.addView(bar, lp_bar)
        
        tv = TextView(ctx)
        tv.setText(reply_text)
        tv.setTextSize(13)
        tv.setTextColor(_c(COLOR_TEXT_PR))
        tv.setAlpha(0.75)
        tv.setSingleLine(False)
        lp = LinearLayout.LayoutParams(0, ViewGroup.LayoutParams.WRAP_CONTENT, 1.0)
        lp.leftMargin = _dp(10)
        row.addView(tv, lp)
        return row

    def _top_button(self, ctx, text: str, cb):
        b = TextView(ctx)
        b.setText(text)
        b.setTextSize(14)
        b.setTextColor(_c(COLOR_TEXT_PR))
        b.setTypeface(None, Typeface.BOLD)
        b.setPadding(_dp(16), _dp(10), _dp(16), _dp(10))
        b.setClickable(True)
        b.setBackground(self._bg_rounded("#14FFFFFF", radius_dp=16))
        def on_click(v):
            self._bounce_anim(v)
            try: cb()
            except Exception: pass
        b.setOnClickListener(OnClickListener(on_click))
        return b

    def _primary_button(self, ctx, text: str, cb):
        b = TextView(ctx)
        b.setText(text)
        b.setTextSize(16)
        b.setGravity(Gravity.CENTER)
        b.setTextColor(_c(COLOR_TEXT_PR))
        b.setTypeface(None, Typeface.BOLD)
        b.setPadding(_dp(16), _dp(16), _dp(16), _dp(16))
        b.setClickable(True)
        b.setBackground(self._bg_rounded(self._accent(), radius_dp=16))
        def on_click(v):
            self._bounce_anim(v)
            try: cb()
            except Exception: pass
        b.setOnClickListener(OnClickListener(on_click))
        return b

    def _spacer_h(self, ctx, wdp: int) -> View:
        v = View(ctx)
        v.setLayoutParams(LinearLayout.LayoutParams(_dp(wdp), 1))
        return v

    def _bottom_nav_button(self, ctx, text: str, cb):
        b = TextView(ctx)
        b.setText(text)
        b.setTextSize(12)
        b.setTypeface(None, Typeface.BOLD)
        b.setGravity(Gravity.CENTER)
        b.setTextColor(_c(COLOR_TEXT_PR))
        b.setPadding(_dp(10), _dp(14), _dp(10), _dp(14))
        b.setClickable(True)
        b.setBackground(self._bg_pill("#00000000"))
        def on_click(v):
            self._bounce_anim(v)
            try: cb()
            except Exception: pass
        b.setOnClickListener(OnClickListener(on_click))
        return b

    def _attach_feed_swipe_touch(self, v: Optional[View]):
        if v is None: return
        try:
            if self._feed_item_touch_listener is not None:
                v.setOnTouchListener(self._feed_item_touch_listener)
        except Exception:
            pass

    def _mode_order(self) -> List[str]:
        return ["feed", "cats", "subs", "settings"]

    def _selected_nav_button(self) -> Optional[TextView]:
        if self._mode == "feed": return self._nav_feed_btn
        if self._mode == "cats": return self._nav_cats_btn
        if self._mode == "subs": return self._nav_subs_btn
        if self._mode == "settings": return self._nav_settings_btn
        return None

    def _animate_selected_nav(self):
        btn = self._selected_nav_button()
        if btn is None: return
        try:
            btn.animate().cancel()
            btn.setScaleX(0.94)
            btn.setScaleY(0.94)
            btn.animate().scaleX(1.0).scaleY(1.0).setDuration(180).setInterpolator(DecelerateInterpolator()).start()
        except Exception:
            self._reset_press_state(btn)

    def _mode_index(self, mode: str) -> int:
        order = self._mode_order()
        try: return order.index(mode)
        except Exception: return 0

    def _switch_mode_by_swipe(self, dx: float):
        order = self._mode_order()
        cur = self._mode_index(self._mode)
        step = 1 if float(dx) < 0 else -1
        nxt = max(0, min(len(order) - 1, cur + step))
        if nxt == cur: return
        try:
            if self._main_scroll is not None: self._main_scroll.performHapticFeedback(HapticFeedbackConstants.KEYBOARD_TAP)
        except Exception: pass
        self._set_mode(order[nxt])

    def _update_bottom_nav_state(self):
        try:
            if self._nav_feed_btn is None or self._nav_subs_btn is None or self._nav_cats_btn is None or self._nav_settings_btn is None: return
            is_feed = (self._mode == "feed")
            is_subs = (self._mode == "subs")
            is_cats = (self._mode == "cats")
            is_settings = (self._mode == "settings")

            self._nav_feed_btn.setAlpha(1.0 if is_feed else 0.5)
            self._nav_subs_btn.setAlpha(1.0 if is_subs else 0.5)
            self._nav_cats_btn.setAlpha(1.0 if is_cats else 0.5)
            self._nav_settings_btn.setAlpha(1.0 if is_settings else 0.5)
            
            self._nav_feed_btn.setBackground(self._bg_pill("#26FFFFFF" if is_feed else "#00000000"))
            self._nav_subs_btn.setBackground(self._bg_pill("#26FFFFFF" if is_subs else "#00000000"))
            self._nav_cats_btn.setBackground(self._bg_pill("#26FFFFFF" if is_cats else "#00000000"))
            self._nav_settings_btn.setBackground(self._bg_pill("#26FFFFFF" if is_settings else "#00000000"))
        except Exception: pass

    # ---------- MAIN SCREEN ----------
    def _open(self, fragment):
        self._reload_ui_scale_from_settings()
        self._remove_pencil_hook_view_trigger()
        if self._unread_new_posts > 0:
            self._set_unread_count(0, persist=True)
        if self._overlay is not None: return
        if not fragment: fragment = get_last_fragment()
        if not fragment: return
        activity = fragment.getParentActivity()
        if not activity: return

        overlay = FrameLayout(activity)
        overlay.setLayoutParams(FrameLayout.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.MATCH_PARENT))
        overlay.setBackgroundColor(_c(COLOR_BG))
        overlay.setClickable(True)
        overlay.setFocusable(True)

        decor = activity.getWindow().getDecorView()
        if not isinstance(decor, ViewGroup): return
        try: decor.addView(overlay)
        except Exception: return
        self._bind_back_handler(overlay, lambda: self._handle_back_action(), "_main_back_listener")

        main_frame = FrameLayout(activity)
        main_frame.setLayoutParams(FrameLayout.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.MATCH_PARENT))
        overlay.addView(main_frame)

        # 1. SCROLL VIEW (Background layer)
        sv = ScrollView(activity)
        sv.setLayoutParams(FrameLayout.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.MATCH_PARENT))
        try:
            sv.setFillViewport(True)
            sv.setOverScrollMode(View.OVER_SCROLL_NEVER)
            sv.setVerticalScrollBarEnabled(False)
        except Exception: pass
        main_frame.addView(sv)

        list_container = LinearLayout(activity)
        list_container.setOrientation(LinearLayout.VERTICAL)
        list_container.setPadding(_dp(12), _statusbar_pad() + _dp(80), _dp(12), _dp(100)) # Padding top to clear Top Bar
        sv.addView(list_container, ScrollView.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.WRAP_CONTENT))

        # 2. TOP BAR (Floating layer)
        top_bar = LinearLayout(activity)
        top_bar.setOrientation(LinearLayout.HORIZONTAL)
        top_bar.setGravity(Gravity.CENTER_VERTICAL)
        # Полупрозрачный фон с градиентом для эффекта стекла вверху
        bg_top = GradientDrawable(GradientDrawable.Orientation.TOP_BOTTOM, [_c("#E6060608"), _c("#00060608")])
        top_bar.setBackground(bg_top)
        top_bar.setPadding(_dp(16), _statusbar_pad() + _dp(12), _dp(16), _dp(24))
        top_bar.setClickable(True)
        lp_top = FrameLayout.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.WRAP_CONTENT)
        lp_top.gravity = Gravity.TOP
        main_frame.addView(top_bar, lp_top)

        title = TextView(activity)
        title.setText("ExteraRSS")
        title.setTextSize(26)
        title.setTypeface(None, Typeface.BOLD)
        title.setTextColor(_c(COLOR_TEXT_PR))
        top_bar.addView(title, LinearLayout.LayoutParams(0, ViewGroup.LayoutParams.WRAP_CONTENT, 1.0))

        source_btn = self._top_button(activity, self._top_filter_label(), lambda: self._open_top_filter_picker())
        self._source_btn = source_btn
        top_bar.addView(source_btn)
        top_bar.addView(self._spacer_h(activity, 8))
        close_btn = self._top_button(activity, " ✕ ", lambda: self._close(animated=True))
        close_btn.setBackground(self._bg_rounded("#33FF3B30", radius_dp=16)) # Акцентный выход
        top_bar.addView(close_btn)

        # 3. REFRESH PILL (Dynamic Island style)
        refresh_bar = LinearLayout(activity)
        refresh_bar.setOrientation(LinearLayout.HORIZONTAL)
        refresh_bar.setGravity(Gravity.CENTER_VERTICAL)
        refresh_bar.setPadding(_dp(16), _dp(12), _dp(16), _dp(12))
        refresh_bar.setBackground(self._bg_pill(COLOR_CARD, COLOR_STROKE, stroke_dp=1))
        refresh_bar.setElevation(_dp(8))
        refresh_bar.setVisibility(View.GONE)

        pb = ProgressBar(activity)
        try: pb.setIndeterminate(True)
        except Exception: pass
        refresh_bar.addView(pb, LinearLayout.LayoutParams(_dp(20), _dp(20)))

        txt = TextView(activity)
        txt.setText(_tr("Обновление… ", "Refreshing… "))
        txt.setTextSize(14)
        txt.setTypeface(None, Typeface.BOLD)
        txt.setTextColor(_c(COLOR_TEXT_PR))
        lp_txt = LinearLayout.LayoutParams(ViewGroup.LayoutParams.WRAP_CONTENT, ViewGroup.LayoutParams.WRAP_CONTENT)
        lp_txt.leftMargin = _dp(12)
        refresh_bar.addView(txt, lp_txt)

        lp_rb = FrameLayout.LayoutParams(ViewGroup.LayoutParams.WRAP_CONTENT, ViewGroup.LayoutParams.WRAP_CONTENT)
        lp_rb.gravity = int(Gravity.TOP | Gravity.CENTER_HORIZONTAL)
        lp_rb.topMargin = _statusbar_pad() + _dp(70)
        main_frame.addView(refresh_bar, lp_rb)
        self._refresh_bar = refresh_bar

        # 4. BOTTOM NAV (Floating layer)
        bottom_nav = LinearLayout(activity)
        bottom_nav.setOrientation(LinearLayout.HORIZONTAL)
        bottom_nav.setGravity(Gravity.CENTER_VERTICAL)
        bottom_nav.setPadding(_dp(8), _dp(8), _dp(8), _dp(8))
        bottom_nav.setBackground(self._bg_pill("#E6121216", COLOR_STROKE, stroke_dp=1))
        bottom_nav.setElevation(_dp(16))
        
        lp_nav = FrameLayout.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.WRAP_CONTENT)
        lp_nav.gravity = int(Gravity.BOTTOM | Gravity.CENTER_HORIZONTAL)
        lp_nav.leftMargin = _dp(24)
        lp_nav.rightMargin = _dp(24)
        lp_nav.bottomMargin = _dp(self._ui_pad + 24)
        main_frame.addView(bottom_nav, lp_nav)

        nav_feed = self._bottom_nav_button(activity, _tr("Лента", "Feed"), lambda: self._set_mode("feed"))
        nav_cats = self._bottom_nav_button(activity, _tr("Категории", "Categories"), lambda: self._set_mode("cats"))
        nav_subs = self._bottom_nav_button(activity, _tr("Подписки", "Subscriptions"), lambda: self._set_mode("subs"))
        nav_settings = self._bottom_nav_button(activity, _tr("Настройки", "Settings"), lambda: self._set_mode("settings"))
        self._nav_feed_btn = nav_feed
        self._nav_cats_btn = nav_cats
        self._nav_subs_btn = nav_subs
        self._nav_settings_btn = nav_settings

        lp_tab = LinearLayout.LayoutParams(0, ViewGroup.LayoutParams.WRAP_CONTENT, 1.0)
        lp_tab.leftMargin = _dp(2)
        lp_tab.rightMargin = _dp(2)

        bottom_nav.addView(nav_feed, lp_tab)
        bottom_nav.addView(nav_cats, lp_tab)
        bottom_nav.addView(nav_subs, lp_tab)
        bottom_nav.addView(nav_settings, lp_tab)

        self._main_scroll = sv
        self._overlay = overlay
        self._main_frame = main_frame
        self._list_container = list_container
        self._mode = "feed"
        self._update_bottom_nav_state()

        try:
            self._main_touch_listener = _OnTouchListener(self._handle_global_touch)
            sv.setOnTouchListener(self._main_touch_listener)
            overlay.setOnTouchListener(self._main_touch_listener)
        except Exception:
            self._main_touch_listener = None

        self._render()
        self._focus_view_safe(overlay)
        self._slide_up_enter(overlay, main_frame)

        if self._suppress_open_refresh_once:
            self._suppress_open_refresh_once = False
        elif self.get_setting("auto_refresh", True):
            self._set_refreshing_ui(True)
            self._refresh_async()

    def _close(self, animated: bool):
        overlay = self._overlay
        content = self._main_frame
        if overlay is None: return
        self._close_source_picker_screen(animated=False)

        def detach():
            try:
                parent = overlay.getParent()
                if parent and isinstance(parent, ViewGroup): parent.removeView(overlay)
            except Exception: pass
            self._overlay = None
            self._main_frame = None
            self._list_container = None
            self._main_touch_listener = None
            self._main_back_listener = None
            self._source_btn = None
            self._nav_feed_btn = None
            self._nav_cats_btn = None
            self._nav_subs_btn = None
            self._nav_settings_btn = None
            self._gesture_switched = False
            self._bottom_nav_row = None
            self._feed_item_touch_listener = None
            self._ui_seek_listener = None
            self._corner_seek_listener = None
            self._accent_seek_listener = None
            self._bg_minutes_seek_listener = None
            run_on_ui_thread(self._install_pencil_hook_view_trigger)

        if not animated or content is None: detach(); return
        self._slide_down_exit(overlay, content)
        try: AndroidUtilities.runOnUIThread(Runnable(detach), 200)
        except Exception: run_on_ui_thread(detach)

    def _set_mode(self, mode: str):
        if mode == self._mode:
            self._update_bottom_nav_state()
            self._animate_selected_nav()
            return
        self._close_source_picker_screen(animated=False)
        prev_idx = self._mode_index(self._mode)
        self._mode = mode
        new_idx = self._mode_index(mode)
        self._animate_list_once = True
        self._update_source_button()
        self._update_bottom_nav_state()
        container = self._list_container
        if container is None:
            self._render(); return
        try: container.animate().cancel()
        except Exception: pass
        self._render()
        self._update_bottom_nav_state()
        self._animate_selected_nav()
        try:
            container.setAlpha(1.0)
            container.setTranslationX(0.0)
        except Exception: pass

    # ---------- Add feed screen ----------
    def _open_add_feed_screen(self, fragment):
        if self._add_overlay is not None: return
        if not fragment: fragment = get_last_fragment()
        if not fragment: return
        activity = fragment.getParentActivity()
        if not activity: return
        decor = activity.getWindow().getDecorView()
        if not isinstance(decor, ViewGroup): return

        overlay = FrameLayout(activity)
        overlay.setLayoutParams(FrameLayout.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.MATCH_PARENT))
        overlay.setBackgroundColor(_c(COLOR_BG))
        overlay.setClickable(True); overlay.setFocusable(True)

        content = LinearLayout(activity)
        content.setOrientation(LinearLayout.VERTICAL)
        content.setLayoutParams(FrameLayout.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.MATCH_PARENT))
        content.setPadding(_dp(16), _statusbar_pad() + _dp(10), _dp(16), _dp(14))
        overlay.addView(content)

        top = LinearLayout(activity)
        top.setOrientation(LinearLayout.HORIZONTAL)
        top.setGravity(Gravity.CENTER_VERTICAL)
        content.addView(top)

        back = self._top_button(activity, " ← ", lambda: self._close_add_feed_screen(animated=True))
        top.addView(back)
        top.addView(self._spacer_h(activity, 12))

        title = TextView(activity)
        title.setText(_tr("Добавить RSS", "Add RSS"))
        title.setTextSize(26)
        title.setTypeface(None, Typeface.BOLD)
        title.setTextColor(_c(COLOR_TEXT_PR))
        top.addView(title, LinearLayout.LayoutParams(0, ViewGroup.LayoutParams.WRAP_CONTENT, 1.0))

        content.addView(self._spacer_h(activity, 1), LinearLayout.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, _dp(24)))

        lbl = TextView(activity)
        lbl.setText(_tr("Адрес (RSS / @username / t.me/link)", "URL (RSS / @username / link)"))
        lbl.setTextSize(14)
        lbl.setTextColor(_c(COLOR_TEXT_SEC))
        content.addView(lbl)

        url_input = EditText(activity)
        url_input.setHint(_tr("https://...", "https://..."))
        url_input.setSingleLine(True)
        url_input.setPadding(_dp(16), _dp(16), _dp(16), _dp(16))
        url_input.setTextColor(_c(COLOR_TEXT_PR))
        try: url_input.setHintTextColor(_c("#66FFFFFF"))
        except Exception: pass
        url_input.setBackground(self._bg_rounded(COLOR_CARD, COLOR_STROKE, stroke_dp=1, radius_dp=16))
        lp = LinearLayout.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.WRAP_CONTENT)
        lp.topMargin = _dp(8)
        content.addView(url_input, lp)

        lbl_cat = TextView(activity)
        lbl_cat.setText(_tr("Категория (необязательно)", "Category (optional)"))
        lbl_cat.setTextSize(14)
        lbl_cat.setTextColor(_c(COLOR_TEXT_SEC))
        lp_lbl_cat = LinearLayout.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.WRAP_CONTENT)
        lp_lbl_cat.topMargin = _dp(24)
        content.addView(lbl_cat, lp_lbl_cat)

        category_input = EditText(activity)
        category_input.setHint(_tr("Новости, IT, Мемы...", "News, IT, Memes..."))
        category_input.setSingleLine(True)
        category_input.setPadding(_dp(16), _dp(16), _dp(16), _dp(16))
        category_input.setTextColor(_c(COLOR_TEXT_PR))
        try: category_input.setHintTextColor(_c("#66FFFFFF"))
        except Exception: pass
        category_input.setBackground(self._bg_rounded(COLOR_CARD, COLOR_STROKE, stroke_dp=1, radius_dp=16))
        lp_cat = LinearLayout.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.WRAP_CONTENT)
        lp_cat.topMargin = _dp(8)
        content.addView(category_input, lp_cat)

        push = View(activity)
        push.setLayoutParams(LinearLayout.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, 0, 1.0))
        content.addView(push)

        add_btn = self._primary_button(activity, _tr("Сохранить", "Save"), lambda: self._add_sub_from_input(url_input, category_input))
        content.addView(add_btn, LinearLayout.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.WRAP_CONTENT))

        self._add_overlay = overlay
        self._add_content = content
        decor.addView(overlay)
        self._bind_back_handler(overlay, lambda: self._handle_back_action(), "_add_back_listener")
        self._slide_up_enter(overlay, content)

    def _add_sub_from_input(self, url_input: EditText, category_input: EditText):
        raw = str(url_input.getText().toString()).strip()
        sub = _norm_sub(raw)
        if not sub:
            try: url_input.setBackground(self._bg_rounded("#33FF3B30", radius_dp=16))
            except Exception: pass
            return
        category = _norm_category(str(category_input.getText().toString()))
        entries = self._get_sub_entries()
        updated = False
        for it in entries:
            if str(it.get("sub") or "") == sub:
                it["category"] = category
                updated = True; break
        if not updated: entries.append({"sub": sub, "category": category})
        self._set_sub_entries(entries)
        if self._overlay is not None: self._set_refreshing_ui(True)
        self._refresh_async()
        self._close_add_feed_screen(animated=True)
        if self._overlay is not None:
            self._mode = "subs"
            self._render()

    def _close_add_feed_screen(self, animated: bool):
        overlay = self._add_overlay
        content = self._add_content
        if overlay is None: return
        def detach():
            try:
                parent = overlay.getParent()
                if parent and isinstance(parent, ViewGroup): parent.removeView(overlay)
            except Exception: pass
            self._add_overlay = None; self._add_content = None; self._add_back_listener = None
        if not animated or content is None: detach(); return
        self._slide_down_exit(overlay, content)
        try: AndroidUtilities.runOnUIThread(Runnable(detach), 200)
        except Exception: run_on_ui_thread(detach)

    def _open_category_screen(self, sub_key: str):
        if self._cat_overlay is not None: return
        if not sub_key: return
        fragment = get_last_fragment()
        if not fragment: return
        activity = fragment.getParentActivity()
        if not activity: return
        decor = activity.getWindow().getDecorView()
        if not isinstance(decor, ViewGroup): return

        target = None
        for it in self._get_sub_entries():
            if str(it.get("sub") or "") == sub_key:
                target = it; break
        if target is None: return

        overlay = FrameLayout(activity)
        overlay.setLayoutParams(FrameLayout.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.MATCH_PARENT))
        overlay.setBackgroundColor(_c(COLOR_BG))
        overlay.setClickable(True); overlay.setFocusable(True)

        content = LinearLayout(activity)
        content.setOrientation(LinearLayout.VERTICAL)
        content.setLayoutParams(FrameLayout.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.MATCH_PARENT))
        content.setPadding(_dp(16), _statusbar_pad() + _dp(10), _dp(16), _dp(14))
        overlay.addView(content)

        top = LinearLayout(activity)
        top.setOrientation(LinearLayout.HORIZONTAL)
        top.setGravity(Gravity.CENTER_VERTICAL)
        content.addView(top)

        back = self._top_button(activity, " ← ", lambda: self._close_category_screen(animated=True))
        top.addView(back)
        top.addView(self._spacer_h(activity, 12))

        title = TextView(activity)
        title.setText(_tr("Редактирование подписки", "Edit subscription"))
        title.setTextSize(26)
        title.setTypeface(None, Typeface.BOLD)
        title.setTextColor(_c(COLOR_TEXT_PR))
        top.addView(title, LinearLayout.LayoutParams(0, ViewGroup.LayoutParams.WRAP_CONTENT, 1.0))

        show = _sub_to_label(sub_key)
        source_tv = TextView(activity)
        source_tv.setText(show)
        source_tv.setTextSize(16)
        source_tv.setTextColor(_c(COLOR_TEXT_PR))
        source_tv.setAlpha(0.8)
        source_tv.setPadding(0, _dp(30), 0, _dp(12))
        content.addView(source_tv)

        link_hint = TextView(activity)
        link_hint.setText(_tr("Ссылка / источник", "Link / source"))
        link_hint.setTextSize(14)
        link_hint.setTextColor(_c(COLOR_TEXT_SEC))
        link_hint.setPadding(0, _dp(12), 0, _dp(8))
        content.addView(link_hint)

        source_input = EditText(activity)
        source_input.setHint(_tr("https://... или @username", "https://... or @username"))
        source_input.setSingleLine(True)
        source_input.setText(sub_key)
        source_input.setPadding(_dp(16), _dp(16), _dp(16), _dp(16))
        source_input.setTextColor(_c(COLOR_TEXT_PR))
        try:
            source_input.setHintTextColor(_c("#66FFFFFF"))
        except Exception:
            pass
        source_input.setBackground(self._bg_rounded(COLOR_CARD, COLOR_STROKE, stroke_dp=1, radius_dp=16))
        content.addView(source_input, LinearLayout.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.WRAP_CONTENT))

        category_input = EditText(activity)
        category_input.setHint(_tr("Любая категория", "Any category"))
        category_input.setSingleLine(True)
        category_input.setText(_norm_category(target.get("category", "")))
        category_input.setPadding(_dp(16), _dp(16), _dp(16), _dp(16))
        category_input.setTextColor(_c(COLOR_TEXT_PR))
        try: category_input.setHintTextColor(_c("#66FFFFFF"))
        except Exception: pass
        category_input.setBackground(self._bg_rounded(COLOR_CARD, COLOR_STROKE, stroke_dp=1, radius_dp=16))
        lp_cat = LinearLayout.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.WRAP_CONTENT)
        lp_cat.topMargin = _dp(10)
        content.addView(category_input, lp_cat)

        push = View(activity)
        push.setLayoutParams(LinearLayout.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, 0, 1.0))
        content.addView(push)

        save_btn = self._primary_button(activity, _tr("Сохранить", "Save"), lambda: self._save_sub_edit(sub_key, source_input, category_input))
        content.addView(save_btn, LinearLayout.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.WRAP_CONTENT))

        self._cat_overlay = overlay
        self._cat_content = content
        decor.addView(overlay)
        self._bind_back_handler(overlay, lambda: self._handle_back_action(), "_cat_back_listener")
        self._slide_up_enter(overlay, content)

    def _save_sub_edit(self, sub_key: str, source_input: EditText, category_input: EditText):
        new_sub = _norm_sub(str(source_input.getText().toString()))
        if not new_sub:
            try:
                Toast.makeText(ApplicationLoader.applicationContext, _tr("Укажите корректный источник", "Enter a valid source"), Toast.LENGTH_SHORT).show()
            except Exception:
                pass
            return
        cat = _norm_category(str(category_input.getText().toString()))
        entries = self._get_sub_entries()
        changed = False
        exists_same = False
        for it in entries:
            cur = str(it.get("sub") or "")
            if cur != sub_key and cur == new_sub:
                exists_same = True
                break
        if exists_same:
            try:
                Toast.makeText(ApplicationLoader.applicationContext, _tr("Такая подписка уже есть", "Subscription already exists"), Toast.LENGTH_SHORT).show()
            except Exception:
                pass
            return
        for it in entries:
            if str(it.get("sub") or "") == sub_key:
                it["sub"] = new_sub
                it["category"] = cat
                changed = True; break
        if not changed: return
        self._set_sub_entries(entries)
        if self._sub_exclude_filters:
            updated = []
            for s in self._sub_exclude_filters:
                if s == sub_key:
                    updated.append(new_sub)
                else:
                    updated.append(s)
            self._sub_exclude_filters = _uniq_keep_order(updated)
            try:
                self.set_setting("sub_exclude_filters", json.dumps(self._sub_exclude_filters, ensure_ascii=False))
            except Exception:
                pass
        self._close_category_screen(animated=True)
        if self._overlay is not None:
            self._render()
            self._set_refreshing_ui(True)
        self._refresh_async()

    def _close_category_screen(self, animated: bool):
        overlay = self._cat_overlay
        content = self._cat_content
        if overlay is None: return
        def detach():
            try:
                parent = overlay.getParent()
                if parent and isinstance(parent, ViewGroup): parent.removeView(overlay)
            except Exception: pass
            self._cat_overlay = None; self._cat_content = None; self._cat_back_listener = None
        if not animated or content is None: detach(); return
        self._slide_down_exit(overlay, content)
        try: AndroidUtilities.runOnUIThread(Runnable(detach), 200)
        except Exception: run_on_ui_thread(detach)

    # ---------- Post screen ----------
    def _open_post_screen(self, fragment, item: Dict[str, Any]):
        if self._post_overlay is not None: return
        if not fragment: fragment = get_last_fragment()
        if not fragment: return
        activity = fragment.getParentActivity()
        if not activity: return
        decor = activity.getWindow().getDecorView()
        if not isinstance(decor, ViewGroup): return

        title_raw = item.get("title", "") or ""
        if not str(title_raw).strip(): title_raw = item.get("voice", "") or item.get("doc", "") or ""
        link = item.get("link", "")
        src = _format_source_line(item)
        cat = _norm_category(item.get("category", ""))
        sort_ts = int(item.get("sort_ts", 0) or 0)
        body_raw = item.get("text", "") or ""
        images = _norm_images_list(item.get("images", []))
        if not images:
            one = _upgrade_image_url(item.get("image", ""))
            if one: images = [one]

        title = _strip_tags_and_format(title_raw)
        body = _strip_tags_and_format(body_raw)

        overlay = FrameLayout(activity)
        overlay.setLayoutParams(FrameLayout.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.MATCH_PARENT))
        overlay.setBackgroundColor(_c(COLOR_BG))
        overlay.setClickable(True); overlay.setFocusable(True)

        content = LinearLayout(activity)
        content.setOrientation(LinearLayout.VERTICAL)
        content.setLayoutParams(FrameLayout.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.MATCH_PARENT))
        content.setPadding(0, _statusbar_pad() + _dp(10), 0, 0)
        overlay.addView(content)

        top = LinearLayout(activity)
        top.setOrientation(LinearLayout.HORIZONTAL)
        top.setGravity(Gravity.CENTER_VERTICAL)
        top.setPadding(_dp(16), 0, _dp(16), _dp(12))
        content.addView(top)

        back = self._top_button(activity, " ← ", lambda: self._close_post_screen(animated=True))
        top.addView(back)
        top.addView(self._spacer_h(activity, 12))

        t = TextView(activity)
        t.setText(_tr("Публикация", "Post"))
        t.setTextSize(24)
        t.setTypeface(None, Typeface.BOLD)
        t.setTextColor(_c(COLOR_TEXT_PR))
        top.addView(t, LinearLayout.LayoutParams(0, ViewGroup.LayoutParams.WRAP_CONTENT, 1.0))

        go_btn = self._top_button(activity, _tr("Оригинал", "Open"), lambda: self._open_link(get_last_fragment(), link))
        top.addView(go_btn)

        sv = ScrollView(activity)
        sv.setLayoutParams(LinearLayout.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.MATCH_PARENT))
        try: sv.setOverScrollMode(View.OVER_SCROLL_NEVER)
        except Exception: pass
        content.addView(sv)
        
        col = LinearLayout(activity)
        col.setOrientation(LinearLayout.VERTICAL)
        # Отступы для контента внутри скролла
        col.setPadding(_dp(16), _dp(12), _dp(16), _dp(100))
        sv.addView(col)
        
        if title:
            tv_title = TextView(activity)
            tv_title.setText(title)
            tv_title.setTextSize(28)
            tv_title.setTypeface(None, Typeface.BOLD)
            tv_title.setTextColor(_c(COLOR_TEXT_PR))
            tv_title.setPadding(0, 0, 0, _dp(12))
            col.addView(tv_title)
        else:
            col.addView(self._spacer_h(activity, 1), LinearLayout.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, _dp(12)))

        meta = []
        if src: meta.append(src)
        if cat: meta.append(f"#{cat}")
        dt = _format_ru_datetime(sort_ts)
        if dt: meta.append(dt)
        meta_line = " • ".join(meta).strip()
        if meta_line:
            tv_meta = TextView(activity)
            tv_meta.setText(meta_line)
            tv_meta.setTextSize(14)
            tv_meta.setTextColor(_c(COLOR_TEXT_SEC))
            tv_meta.setPadding(0, 0, 0, _dp(20))
            col.addView(tv_meta)

        reply_raw = str(item.get("reply", "") or "").strip()
        reply = _clean_reply_for_ui(reply_raw, item)
        if reply:
            src_line = _format_source_line(item)
            shown = f"{src_line}:\n↩ " + reply if src_line else f"↩ {reply}"
            chip = self._reply_bubble(activity, shown)
            lp = LinearLayout.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.WRAP_CONTENT)
            lp.bottomMargin = _dp(20)
            col.addView(chip, lp)

        # Edge-to-edge style images inside the padded col by giving negative margin? No, just round them
        loading_images_tv = None
        if len(images) > 1:
            loading_images_tv = TextView(activity)
            loading_images_tv.setText(_tr("Загрузка изображений…", "Loading images…"))
            loading_images_tv.setTextSize(13)
            loading_images_tv.setTextColor(_c(COLOR_TEXT_SEC))
            loading_images_tv.setPadding(0, 0, 0, _dp(10))
            col.addView(loading_images_tv)

        post_mode = str(self._post_img_layout_mode or "primary")
        if post_mode == "grid" and len(images) > 1:
            grid = LinearLayout(activity)
            grid.setOrientation(LinearLayout.VERTICAL)
            lp_grid = LinearLayout.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.WRAP_CONTENT)
            lp_grid.bottomMargin = _dp(24)
            col.addView(grid, lp_grid)
            row = None
            for img_idx, img_url in enumerate(images):
                if img_idx % 2 == 0:
                    row = LinearLayout(activity)
                    row.setOrientation(LinearLayout.HORIZONTAL)
                    row.setGravity(Gravity.CENTER_VERTICAL)
                    if img_idx > 0:
                        try: row.setPadding(0, _dp(10), 0, 0)
                        except Exception: pass
                    grid.addView(row, LinearLayout.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.WRAP_CONTENT))
                iv = ImageView(activity)
                iv.setVisibility(View.GONE)
                iv.setAdjustViewBounds(True)
                try: iv.setScaleType(ImageView.ScaleType.CENTER_CROP)
                except Exception: pass
                iv.setBackground(self._bg_rounded(COLOR_CARD, COLOR_STROKE, stroke_dp=1, radius_dp=18))
                self._apply_rounded_clip(iv)
                iv.setClickable(True)
                u = img_url
                def on_img_click(_v, uu=u, all_images=images, idx=img_idx):
                    self._bounce_anim(_v)
                    try: self._open_image_screen(get_last_fragment(), uu, all_images, idx)
                    except Exception: pass
                iv.setOnClickListener(OnClickListener(on_img_click))
                lp_iv = LinearLayout.LayoutParams(0, _dp(220), 1.0)
                if img_idx % 2 == 0:
                    lp_iv.rightMargin = _dp(6)
                else:
                    lp_iv.leftMargin = _dp(6)
                row.addView(iv, lp_iv)
                self._load_image_into(img_url, iv, quick_preview=True, loading_label=loading_images_tv)
            if len(images) % 2 == 1 and row is not None:
                spacer = View(activity)
                row.addView(spacer, LinearLayout.LayoutParams(0, _dp(220), 1.0))
        else:
            for img_idx, img_url in enumerate(images):
                iv = ImageView(activity)
                iv.setVisibility(View.GONE)
                iv.setAdjustViewBounds(True)
                try: iv.setScaleType(ImageView.ScaleType.FIT_CENTER)
                except Exception: pass
                iv.setBackground(self._bg_rounded(COLOR_CARD, COLOR_STROKE, stroke_dp=1, radius_dp=20))
                self._apply_rounded_clip(iv)

                iv.setClickable(True)
                u = img_url
                def on_img_click(_v, uu=u, all_images=images, idx=img_idx):
                    self._bounce_anim(_v)
                    try: self._open_image_screen(get_last_fragment(), uu, all_images, idx)
                    except Exception: pass
                iv.setOnClickListener(OnClickListener(on_img_click))

                ilp = LinearLayout.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, _dp(500))
                ilp.bottomMargin = _dp(12 if img_idx < len(images) - 1 else 24)
                col.addView(iv, ilp)
                self._load_image_into(img_url, iv, quick_preview=True, loading_label=loading_images_tv)

        if body:
            tv_body = TextView(activity)
            tv_body.setText(body)
            tv_body.setTextSize(17)
            tv_body.setTextColor(_c("#EBEBF5"))
            try: tv_body.setLineSpacing(_dp(6), 1.2)
            except Exception: pass
            tv_body.setPadding(0, 0, 0, _dp(32))
            col.addView(tv_body)

        self._post_overlay = overlay
        self._post_content = content
        decor.addView(overlay)
        self._bind_back_handler(overlay, lambda: self._handle_back_action(), "_post_back_listener")
        self._slide_up_enter(overlay, content)

    def _close_post_screen(self, animated: bool):
        overlay = self._post_overlay
        content = self._post_content
        if overlay is None: return
        def detach():
            try:
                parent = overlay.getParent()
                if parent and isinstance(parent, ViewGroup): parent.removeView(overlay)
            except Exception: pass
            self._post_overlay = None; self._post_content = None; self._post_back_listener = None
        if not animated or content is None: detach(); return
        self._slide_down_exit(overlay, content)
        try: AndroidUtilities.runOnUIThread(Runnable(detach), 200)
        except Exception: run_on_ui_thread(detach)

    # ---------- Image fullscreen screen ----------
    def _open_image_screen(self, fragment, url: str, images: Optional[List[str]] = None, start_index: int = 0):
        if not url: return
        if self._img_overlay is not None: return
        if not fragment: fragment = get_last_fragment()
        if not fragment: return
        activity = fragment.getParentActivity()
        if not activity: return
        decor = activity.getWindow().getDecorView()
        if not isinstance(decor, ViewGroup): return

        overlay = FrameLayout(activity)
        overlay.setLayoutParams(FrameLayout.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.MATCH_PARENT))
        overlay.setBackgroundColor(_c("#F2000000"))
        overlay.setClickable(True); overlay.setFocusable(True)

        content = LinearLayout(activity)
        content.setOrientation(LinearLayout.VERTICAL)
        content.setLayoutParams(FrameLayout.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.MATCH_PARENT))
        content.setPadding(_dp(16), _statusbar_pad() + _dp(10), _dp(16), _dp(14))
        overlay.addView(content)

        top = LinearLayout(activity)
        top.setOrientation(LinearLayout.HORIZONTAL)
        top.setGravity(Gravity.CENTER_VERTICAL)
        content.addView(top)

        back = self._top_button(activity, " ✕ ", lambda: self._close_image_screen(animated=True))
        top.addView(back)
        top.addView(TextView(activity), LinearLayout.LayoutParams(0, ViewGroup.LayoutParams.WRAP_CONTENT, 1.0))
        open_btn = self._top_button(activity, _tr("Браузер", "Browser"), lambda: self._open_link(get_last_fragment(), url))
        top.addView(open_btn)

        zoom_row = LinearLayout(activity)
        zoom_row.setOrientation(LinearLayout.HORIZONTAL)
        zoom_row.setGravity(Gravity.CENTER_VERTICAL)
        zoom_row.setPadding(0, _dp(8), 0, _dp(4))
        content.addView(zoom_row)

        image_list = _norm_images_list(images or [])
        if not image_list:
            image_list = [_upgrade_image_url(url)]
        if not image_list:
            image_list = [url]
        idx = int(start_index)
        if idx < 0: idx = 0
        if idx >= len(image_list): idx = len(image_list) - 1
        state = {"idx": idx}

        image_pos_tv = TextView(activity)
        image_pos_tv.setTextColor(_c(COLOR_TEXT_SEC))
        image_pos_tv.setTextSize(13)
        zoom_row.addView(TextView(activity), LinearLayout.LayoutParams(0, ViewGroup.LayoutParams.WRAP_CONTENT, 1.0))
        zoom_row.addView(image_pos_tv)

        iv = ImageView(activity)
        iv.setVisibility(View.GONE)
        iv.setAdjustViewBounds(True)
        try: iv.setScaleType(ImageView.ScaleType.FIT_CENTER)
        except Exception: pass
        iv.setBackground(self._bg_rounded("#00000000"))

        zoom = {"scale": 1.0, "base_dist": 0.0, "tx": 0.0, "ty": 0.0, "pan_x": 0.0, "pan_y": 0.0, "swipe_x": 0.0, "swipe_y": 0.0}

        def _max_pan_x_for(scale: float) -> float:
            try:
                vw = float(iv.getWidth())
                if vw <= 0.0: vw = float(iv.getMeasuredWidth())
            except Exception:
                vw = 0.0
            return max(0.0, (vw * (max(1.0, scale) - 1.0)) / 2.0)

        def _max_pan_y_for(scale: float) -> float:
            try:
                vh = float(iv.getHeight())
                if vh <= 0.0: vh = float(iv.getMeasuredHeight())
            except Exception:
                vh = 0.0
            return max(0.0, (vh * (max(1.0, scale) - 1.0)) / 2.0)

        def _apply_pan(tx: float, ty: float):
            sc = float(zoom.get("scale", 1.0))
            if sc <= 1.0:
                tx = 0.0
                ty = 0.0
            mx = _max_pan_x_for(sc)
            my = _max_pan_y_for(sc)
            if tx > mx: tx = mx
            if tx < -mx: tx = -mx
            if ty > my: ty = my
            if ty < -my: ty = -my
            zoom["tx"] = float(tx)
            zoom["ty"] = float(ty)
            try:
                iv.setTranslationX(float(tx))
                iv.setTranslationY(float(ty))
            except Exception:
                pass

        def _apply_image_by_index(new_idx: int):
            if new_idx < 0 or new_idx >= len(image_list):
                return
            state["idx"] = int(new_idx)
            try:
                image_pos_tv.setText(f"{int(state['idx']) + 1}/{len(image_list)}")
            except Exception:
                pass
            _apply_zoom(1.0)
            _apply_pan(0.0, 0.0)
            self._load_image_into(image_list[int(state["idx"])], iv)

        def _shift_image(delta: int):
            ni = int(state.get("idx", 0)) + int(delta)
            if ni < 0 or ni >= len(image_list):
                return
            _apply_image_by_index(ni)

        def _apply_zoom(ns: float):
            if ns < 1.0: ns = 1.0
            if ns > 4.0: ns = 4.0
            zoom["scale"] = ns
            try:
                iv.setScaleX(ns)
                iv.setScaleY(ns)
            except Exception:
                pass
            if ns <= 1.0:
                _apply_pan(0.0, 0.0)
            else:
                _apply_pan(float(zoom.get("tx", 0.0)), float(zoom.get("ty", 0.0)))

        def _dist(ev):
            try:
                if int(ev.getPointerCount()) < 2: return 0.0
                dx = float(ev.getX(0) - ev.getX(1))
                dy = float(ev.getY(0) - ev.getY(1))
                return (dx * dx + dy * dy) ** 0.5
            except Exception:
                return 0.0

        def _on_img_touch(_v, ev):
            try:
                try: act = int(ev.getActionMasked())
                except Exception: act = int(ev.getAction())
                pcount = int(ev.getPointerCount())
            except Exception:
                return False
            try:
                if pcount >= 2 and act in (int(MotionEvent.ACTION_DOWN), int(MotionEvent.ACTION_POINTER_DOWN), int(MotionEvent.ACTION_MOVE)):
                    try:
                        par = iv.getParent()
                        if par is not None: par.requestDisallowInterceptTouchEvent(True)
                    except Exception:
                        pass
                if act in (int(MotionEvent.ACTION_POINTER_DOWN), int(MotionEvent.ACTION_DOWN)) and pcount >= 2:
                    zoom["base_dist"] = _dist(ev)
                    try:
                        zoom["pan_x"] = float(ev.getRawX())
                        zoom["pan_y"] = float(ev.getRawY())
                    except Exception:
                        pass
                    return True
                if act == int(MotionEvent.ACTION_MOVE) and pcount >= 2:
                    d = _dist(ev)
                    bd = float(zoom.get("base_dist", 0.0))
                    if bd > 0.0 and d > 0.0:
                        cur_sc = float(zoom.get("scale", 1.0))
                        tgt_sc = cur_sc * (d / bd)
                        smooth_sc = cur_sc + (tgt_sc - cur_sc) * 0.35
                        _apply_zoom(smooth_sc)
                        zoom["base_dist"] = d
                    return True
                if pcount == 1 and act == int(MotionEvent.ACTION_DOWN):
                    try:
                        zoom["pan_x"] = float(ev.getRawX())
                        zoom["pan_y"] = float(ev.getRawY())
                        zoom["swipe_x"] = float(ev.getRawX())
                        zoom["swipe_y"] = float(ev.getRawY())
                        try:
                            par = iv.getParent()
                            if par is not None: par.requestDisallowInterceptTouchEvent(True)
                        except Exception:
                            pass
                    except Exception:
                        pass
                    return True
                if pcount == 1 and act == int(MotionEvent.ACTION_MOVE):
                    sc = float(zoom.get("scale", 1.0))
                    if sc > 1.0:
                        try:
                            rx = float(ev.getRawX())
                            ry = float(ev.getRawY())
                            dx = rx - float(zoom.get("pan_x", rx))
                            dy = ry - float(zoom.get("pan_y", ry))
                            zoom["pan_x"] = rx
                            zoom["pan_y"] = ry
                            _apply_pan(float(zoom.get("tx", 0.0)) + dx, float(zoom.get("ty", 0.0)) + dy)
                            try:
                                par = iv.getParent()
                                if par is not None: par.requestDisallowInterceptTouchEvent(True)
                            except Exception:
                                pass
                            return True
                        except Exception:
                            return True
                    return False
                if act in (int(MotionEvent.ACTION_POINTER_UP), int(MotionEvent.ACTION_UP), int(MotionEvent.ACTION_CANCEL)):
                    if pcount <= 1 and act == int(MotionEvent.ACTION_UP) and float(zoom.get("scale", 1.0)) <= 1.01 and len(image_list) > 1:
                        try:
                            dx = float(ev.getRawX()) - float(zoom.get("swipe_x", 0.0))
                            dy = abs(float(ev.getRawY()) - float(zoom.get("swipe_y", 0.0)))
                            if abs(dx) >= float(_dp(44)) and dy <= float(_dp(72)):
                                _shift_image(-1 if dx > 0 else 1)
                                return True
                        except Exception:
                            pass
                    zoom["base_dist"] = 0.0
                    if float(zoom.get("scale", 1.0)) <= 1.01:
                        _apply_zoom(1.0)
                    return bool(float(zoom.get("scale", 1.0)) > 1.0)
            except Exception:
                return False
            return bool(float(zoom.get("scale", 1.0)) > 1.0)

        try: iv.setOnTouchListener(_OnTouchListener(_on_img_touch))
        except Exception: pass
        
        ilp = LinearLayout.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.MATCH_PARENT)
        ilp.topMargin = _dp(16)
        content.addView(iv, ilp)

        _apply_image_by_index(int(state.get("idx", 0)))

        self._img_overlay = overlay
        self._img_content = content
        decor.addView(overlay)
        self._bind_back_handler(overlay, lambda: self._handle_back_action(), "_img_back_listener")

        try:
            overlay.setAlpha(0.0)
            overlay.animate().alpha(1.0).setDuration(250).start()
        except Exception: pass

    def _close_image_screen(self, animated: bool):
        overlay = self._img_overlay
        content = self._img_content
        if overlay is None: return
        def detach():
            try:
                parent = overlay.getParent()
                if parent and isinstance(parent, ViewGroup): parent.removeView(overlay)
            except Exception: pass
            self._img_overlay = None; self._img_content = None; self._img_back_listener = None
        if not animated or content is None: detach(); return
        try:
            overlay.animate().alpha(0.0).setDuration(200).start()
            content.getChildAt(1).animate().scaleX(0.8).scaleY(0.8).setDuration(200).start()
        except Exception: pass
        try: AndroidUtilities.runOnUIThread(Runnable(detach), 220)
        except Exception: run_on_ui_thread(detach)

    # ---------- image loading ----------
    def _load_image_into(self, url: str, iv: ImageView, quick_preview: bool = False, loading_label: Optional[TextView] = None):
        url = _upgrade_image_url(url)
        if not url: return

        def start_loading_pulse(lbl: Optional[TextView]):
            if lbl is None:
                return
            def _tick():
                try:
                    if int(lbl.getVisibility()) != int(View.VISIBLE):
                        return
                    try:
                        lbl.animate().alpha(0.42).setDuration(320).withEndAction(
                            Runnable(lambda: lbl.animate().alpha(1.0).setDuration(320).start())
                        ).start()
                    except Exception:
                        pass
                    try:
                        AndroidUtilities.runOnUIThread(Runnable(_tick), 700)
                    except Exception:
                        pass
                except Exception:
                    pass
            run_on_ui_thread(_tick)

        with self._img_cache_lock: bmp = self._img_cache.get(url)
        if bmp is not None:
            try: iv.setImageBitmap(bmp); iv.setVisibility(View.VISIBLE)
            except Exception: pass
            if loading_label is not None:
                try:
                    loading_label.setAlpha(1.0)
                    loading_label.setVisibility(View.GONE)
                except Exception: pass
            try:
                iv.setAlpha(1.0)
                iv.clearColorFilter()
            except Exception: pass
            return

        if loading_label is not None:
            try:
                loading_label.setText(_tr("Загрузка превью…", "Loading preview…"))
                loading_label.setAlpha(1.0)
                loading_label.setVisibility(View.VISIBLE)
            except Exception:
                pass
            start_loading_pulse(loading_label)

        def decode_preview(data: bytes):
            try:
                opts_p = BitmapFactory.Options()
                opts_p.inPreferredConfig = Bitmap.Config.RGB_565 if Bitmap is not None else None
                opts_p.inSampleSize = 12
                return BitmapFactory.decodeByteArray(data, 0, len(data), opts_p)
            except Exception:
                return None

        def decode_full(data: bytes):
            try:
                if Bitmap is not None:
                    opts = BitmapFactory.Options()
                    opts.inPreferredConfig = Bitmap.Config.ARGB_8888
                    opts.inScaled = False
                    bmp2 = BitmapFactory.decodeByteArray(data, 0, len(data), opts)
                    if bmp2 is not None: return bmp2
            except Exception:
                pass
            try:
                return BitmapFactory.decodeByteArray(data, 0, len(data))
            except Exception:
                return None

        def bg():
            try:
                req = urllib.request.Request(url, headers={"User-Agent": "Exteragram-RSS-Plugin/2.0.0"})
                with urllib.request.urlopen(req, timeout=14) as resp: data = resp.read()

                prev = decode_preview(data)
                if prev is not None:
                    def ui_prev():
                        try:
                            iv.setImageBitmap(prev)
                            iv.setVisibility(View.VISIBLE)
                            iv.setAlpha(0.0)
                            try:
                                iv.setColorFilter(_c("#7AFFFFFF"))
                            except Exception:
                                pass
                            iv.animate().alpha(0.84).setDuration(180).start()
                            if loading_label is not None:
                                try:
                                    loading_label.setText(_tr("Догружаем оригинал…", "Loading full quality…"))
                                except Exception:
                                    pass
                        except Exception:
                            pass
                    run_on_ui_thread(ui_prev)

                bmp2 = decode_full(data)
                if bmp2 is None: return
                with self._img_cache_lock:
                    if len(self._img_cache) > 240:
                        try: self._img_cache.pop(next(iter(self._img_cache)))
                        except Exception: pass
                    self._img_cache[url] = bmp2

                def ui():
                    try:
                        iv.setImageBitmap(bmp2)
                        iv.setVisibility(View.VISIBLE)
                        iv.setAlpha(0.0)
                        try: iv.clearColorFilter()
                        except Exception: pass
                        iv.animate().alpha(1.0).setDuration(260).start()
                    except Exception: pass
                    if loading_label is not None:
                        try:
                            loading_label.setAlpha(1.0)
                            loading_label.setVisibility(View.GONE)
                        except Exception: pass
                run_on_ui_thread(ui)
            except Exception:
                if loading_label is not None:
                    def ui_fail():
                        try: loading_label.setText(_tr("Не удалось загрузить изображения", "Failed to load images"))
                        except Exception: pass
                    run_on_ui_thread(ui_fail)
        threading.Thread(target=bg, daemon=True).start()

    # ---------- render ----------
    def _render(self):
        if not self._list_container: return
        ctx = self._list_container.getContext()
        self._update_source_button()
        self._update_bottom_nav_state()
        try: self._list_container.removeAllViews()
        except Exception: pass

        try:
            if self._mode == "subs": self._render_subs(ctx)
            elif self._mode == "settings": self._render_settings(ctx)
            elif self._mode == "cats": self._render_feed(ctx, by_category=True)
            else: self._render_feed(ctx, by_category=False)
        except Exception as e:
            t = TextView(ctx)
            t.setText(_tr("Ошибка отображения ленты (см. log).", "Failed to render feed (see log)."))
            t.setTextSize(14); t.setTextColor(_c(COLOR_TEXT_PR)); t.setAlpha(0.75)
            self._list_container.addView(t)
        self._animate_list_once = False

    def _render_feed(self, ctx, by_category: bool = False):
        all_items = self._get_cache()

        if not all_items:
            t = TextView(ctx)
            t.setText(_tr("Лента пустая.\nОткрой «Подписки» и нажми «+», затем потяни ленту вниз для обновления.", "Feed is empty.\nOpen Subscriptions and tap , then pull down to refresh."))
            t.setTextSize(15); t.setTextColor(_c(COLOR_TEXT_PR)); t.setAlpha(0.6)
            t.setPadding(_dp(12), _dp(40), _dp(12), _dp(20)); t.setGravity(Gravity.CENTER)
            self._list_container.addView(t)
            return

        items = all_items
        if by_category:
            if self._category_filter:
                filt = self._category_filter
                items = [it for it in all_items if _norm_category(it.get("category", "")) == filt]
            elif self._category_exclude_filters:
                excl_set = set(self._category_exclude_filters)
                items = [it for it in all_items if _norm_category(it.get("category", "")) not in excl_set]
        else:
            if self._source_filter:
                filt = self._source_filter
                items = []
                for it in all_items:
                    src_val = _format_source_line(it).strip()
                    if not src_val: src_val = str(it.get("source", "") or "").strip()
                    if src_val == filt: items.append(it)
            elif self._source_exclude_filters:
                excl_set = set(self._source_exclude_filters)
                items = []
                for it in all_items:
                    src_val = _format_source_line(it).strip()
                    if not src_val: src_val = str(it.get("source", "") or "").strip()
                    if src_val not in excl_set: items.append(it)

        if self._sub_exclude_filters:
            items = [it for it in items if not self._is_item_blocked_by_sub_exclude(it)]

        if not items:
            t = TextView(ctx)
            txt = _tr("По выбранной категории пока ничего нет.\nНажми «Категория», чтобы выбрать другую.", "No items for the selected category yet.") if by_category else _tr("По выбранному источнику пока ничего нет.\nНажми кнопку фильтра сверху.", "No items for the selected source yet.")
            t.setText(txt); t.setTextSize(15); t.setTextColor(_c(COLOR_TEXT_PR)); t.setAlpha(0.6)
            t.setPadding(_dp(12), _dp(40), _dp(12), _dp(20)); t.setGravity(Gravity.CENTER)
            self._list_container.addView(t)
            return

        if by_category:
            info = TextView(ctx)
            info.setText((_tr("Категория", "Category") + f": {self._category_filter}") if self._category_filter else (_tr("Все категории", "All categories")))
            info.setTextSize(14); info.setTypeface(None, Typeface.BOLD); info.setTextColor(_c(self._accent()))
            info.setPadding(_dp(4), 0, 0, _dp(16))
            self._list_container.addView(info)

        items.sort(key=lambda x: int(x.get("sort_ts", x.get("ts", 0) or 0) or 0), reverse=True)
        
        # Обновленный слушатель жестов
        try: self._feed_item_touch_listener = _OnTouchListener(self._handle_global_touch)
        except Exception: self._feed_item_touch_listener = None

        for idx, it in enumerate(items[:max(1, int(self._history_posts or 20))]):
            title = _strip_tags_and_format(str(it.get("title", "") or ""))
            if not title: title = _strip_tags_and_format(str(it.get("voice", "") or ""))[:120]
            if not title: title = _strip_tags_and_format(str(it.get("doc", "") or ""))[:120]
            src = _format_source_line(it)
            cat = _norm_category(it.get("category", ""))
            sort_ts = int(it.get("sort_ts", 0) or 0)
            images = _norm_images_list(it.get("images", []))
            if not images:
                one = _upgrade_image_url(it.get("image", ""))
                if one: images = [one]
            img = images[0] if images else ""
            text = str(it.get("text", "") or "")
            important = ("(!)" in title) or ("(!)" in text)
            veryimportant = ("(!!)" in title) or ("(!!)" in text)

            # --- CARD ARCHITECTURE (Edge-to-edge image style) ---
            card = LinearLayout(ctx)
            card.setOrientation(LinearLayout.VERTICAL)
            card.setClickable(True)
            if important or veryimportant: card.setBackground(self._bg_important_gradient())
            else: card.setBackground(self._bg_rounded(COLOR_CARD, COLOR_STROKE, stroke_dp=1, radius_dp=CORNER_RADIUS_DP))
            self._apply_rounded_clip(card) # Секрет идеальных картинок
            
            lp_card = LinearLayout.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.WRAP_CONTENT)
            lp_card.bottomMargin = _dp(16)
            self._list_container.addView(card, lp_card)

            def on_card_click(v, item=it):
                self._bounce_anim(v)
                try: self._open_post_screen(get_last_fragment(), item)
                except Exception: pass

            card.setOnClickListener(OnClickListener(on_card_click))
            self._attach_feed_swipe_touch(card)

            if self._animate_list_once and idx < 10:
                self._animate_entry(card, idx)

            # HEADER (Source & Meta)
            header = LinearLayout(ctx)
            header.setOrientation(LinearLayout.VERTICAL)
            header.setPadding(_dp(16), _dp(16), _dp(16), _dp(12))
            card.addView(header)
            self._attach_feed_swipe_touch(header)

            tv_src = TextView(ctx)
            tv_src.setText(src)
            tv_src.setTextSize(15)
            tv_src.setTypeface(None, Typeface.BOLD)
            tv_src.setTextColor(_c(COLOR_TEXT_PR))
            header.addView(tv_src)

            meta = []
            if cat: meta.append(f"#{cat}")
            dt = _format_ru_datetime(sort_ts)
            if dt: meta.append(dt)
            meta_line = " • ".join(meta).strip()
            if meta_line:
                tv_meta = TextView(ctx)
                tv_meta.setText(meta_line)
                tv_meta.setTextSize(12)
                tv_meta.setTextColor(_c(COLOR_TEXT_SEC))
                tv_meta.setPadding(0, _dp(2), 0, 0)
                header.addView(tv_meta)

            # IMAGE (Edge to Edge)
            if img:
                iv = ImageView(ctx)
                iv.setVisibility(View.GONE)
                iv.setAdjustViewBounds(True)
                preview_mode = str(self._img_preview_mode or "compact")
                if preview_mode == "full":
                    try: iv.setScaleType(ImageView.ScaleType.FIT_CENTER)
                    except Exception: pass
                    ilp = LinearLayout.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.WRAP_CONTENT)
                else:
                    try: iv.setScaleType(ImageView.ScaleType.CENTER_CROP)
                    except Exception: pass
                    ilp = LinearLayout.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, _dp(240))
                # Нет закруглений, так как card делает clip!
                iv.setBackgroundColor(_c("#00000000")) 
                card.addView(iv, ilp)
                self._attach_feed_swipe_touch(iv)
                self._load_image_into(img, iv, quick_preview=True)

            # CONTENT (Title, text, replies)
            content_box = LinearLayout(ctx)
            content_box.setOrientation(LinearLayout.VERTICAL)
            content_box.setPadding(_dp(16), _dp(12), _dp(16), _dp(16))
            card.addView(content_box)
            self._attach_feed_swipe_touch(content_box)

            if len(images) > 1:
                tv_more = TextView(ctx)
                tv_more.setText(_tr(f"+{len(images) - 1} фото", f"+{len(images) - 1} photos"))
                tv_more.setTextSize(12)
                tv_more.setTypeface(None, Typeface.BOLD)
                tv_more.setTextColor(_c(self._accent()))
                tv_more.setBackground(self._bg_rounded("#267E57C2", radius_dp=8))
                tv_more.setPadding(_dp(8), _dp(4), _dp(8), _dp(4))
                lp_more = LinearLayout.LayoutParams(ViewGroup.LayoutParams.WRAP_CONTENT, ViewGroup.LayoutParams.WRAP_CONTENT)
                lp_more.bottomMargin = _dp(8)
                content_box.addView(tv_more, lp_more)

            reply_raw = str(it.get("reply", "") or "").strip()
            reply_text = _clean_reply_for_ui(reply_raw, it)
            if reply_text:
                shown = f"↩ {reply_text}"
                bubble = self._reply_bubble(ctx, shown)
                lp_bub = LinearLayout.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.WRAP_CONTENT)
                lp_bub.bottomMargin = _dp(12)
                content_box.addView(bubble, lp_bub)

            if title:
                tv_title = TextView(ctx)
                tv_title.setText(title)
                tv_title.setTextSize(20)
                tv_title.setTypeface(None, Typeface.BOLD)
                tv_title.setTextColor(_c("#FF5555" if veryimportant else COLOR_TEXT_PR))
                tv_title.setPadding(0, 0, 0, _dp(6) if text else 0)
                content_box.addView(tv_title)
                self._attach_feed_swipe_touch(tv_title)

            prev = _preview_text(text, 180, title)
            if prev:
                tv_prev = TextView(ctx)
                tv_prev.setText(prev)
                tv_prev.setTextSize(15)
                tv_prev.setTextColor(_c("#D9FFFFFF"))
                try: tv_prev.setLineSpacing(_dp(3), 1.2)
                except Exception: pass
                content_box.addView(tv_prev)
                self._attach_feed_swipe_touch(tv_prev)


    def _render_settings(self, ctx):
        h = TextView(ctx)
        h.setText(_tr("Настройки", "Settings"))
        h.setTextSize(28)
        h.setTypeface(None, Typeface.BOLD)
        h.setTextColor(_c(COLOR_TEXT_PR))
        h.setPadding(_dp(4), _dp(10), 0, _dp(24))
        self._list_container.addView(h)

        hint = TextView(ctx)
        hint.setText(_tr("Масштаб интерфейса (DPI)", "Interface scale (DPI)"))
        hint.setTextSize(14)
        hint.setTextColor(_c(COLOR_TEXT_SEC))
        hint.setPadding(_dp(4), 0, 0, _dp(8))
        self._list_container.addView(hint)

        img_hint = TextView(ctx)
        img_hint.setText(_tr("Размер предпросмотра изображений в ленте", "Feed image preview size"))
        img_hint.setTextSize(14)
        img_hint.setTextColor(_c(COLOR_TEXT_SEC))
        img_hint.setPadding(_dp(4), _dp(8), 0, _dp(8))
        self._list_container.addView(img_hint)

        img_row = LinearLayout(ctx)
        img_row.setOrientation(LinearLayout.HORIZONTAL)
        img_row.setGravity(Gravity.CENTER_VERTICAL)
        lp_img_row = LinearLayout.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.WRAP_CONTENT)
        lp_img_row.bottomMargin = _dp(16)
        self._list_container.addView(img_row, lp_img_row)

        compact_btn = self._top_button(ctx, _tr("Компактно", "Compact"), lambda: self._apply_img_preview_mode_and_reopen("compact"))
        full_btn = self._top_button(ctx, _tr("Полностью", "Full"), lambda: self._apply_img_preview_mode_and_reopen("full"))
        compact_active = (self._img_preview_mode == "compact")
        full_active = (self._img_preview_mode == "full")
        compact_btn.setBackground(self._bg_rounded(self._accent() if compact_active else "#14FFFFFF", radius_dp=16))
        full_btn.setBackground(self._bg_rounded(self._accent() if full_active else "#14FFFFFF", radius_dp=16))
        try: compact_btn.setAlpha(1.0 if compact_active else 0.85)
        except Exception: pass
        try: full_btn.setAlpha(1.0 if full_active else 0.85)
        except Exception: pass

        img_row.addView(compact_btn, LinearLayout.LayoutParams(0, ViewGroup.LayoutParams.WRAP_CONTENT, 1.0))
        img_row.addView(self._spacer_h(ctx, 10))
        img_row.addView(full_btn, LinearLayout.LayoutParams(0, ViewGroup.LayoutParams.WRAP_CONTENT, 1.0))

        post_img_hint = TextView(ctx)
        post_img_hint.setText(_tr("Отображение изображений в посте", "Post images display"))
        post_img_hint.setTextSize(14)
        post_img_hint.setTextColor(_c(COLOR_TEXT_SEC))
        post_img_hint.setPadding(_dp(4), 0, 0, _dp(8))
        self._list_container.addView(post_img_hint)

        post_img_row = LinearLayout(ctx)
        post_img_row.setOrientation(LinearLayout.HORIZONTAL)
        post_img_row.setGravity(Gravity.CENTER_VERTICAL)
        lp_post_img_row = LinearLayout.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.WRAP_CONTENT)
        lp_post_img_row.bottomMargin = _dp(16)
        self._list_container.addView(post_img_row, lp_post_img_row)

        primary_btn = self._top_button(ctx, _tr("Основное", "Primary"), lambda: self._apply_post_img_layout_mode_and_reopen("primary"))
        grid_btn = self._top_button(ctx, _tr("Сетка (все)", "Grid (all)"), lambda: self._apply_post_img_layout_mode_and_reopen("grid"))
        primary_active = (self._post_img_layout_mode == "primary")
        grid_active = (self._post_img_layout_mode == "grid")
        primary_btn.setBackground(self._bg_rounded(self._accent() if primary_active else "#14FFFFFF", radius_dp=16))
        grid_btn.setBackground(self._bg_rounded(self._accent() if grid_active else "#14FFFFFF", radius_dp=16))
        try: primary_btn.setAlpha(1.0 if primary_active else 0.85)
        except Exception: pass
        try: grid_btn.setAlpha(1.0 if grid_active else 0.85)
        except Exception: pass

        post_img_row.addView(primary_btn, LinearLayout.LayoutParams(0, ViewGroup.LayoutParams.WRAP_CONTENT, 1.0))
        post_img_row.addView(self._spacer_h(ctx, 10))
        post_img_row.addView(grid_btn, LinearLayout.LayoutParams(0, ViewGroup.LayoutParams.WRAP_CONTENT, 1.0))

        hist_hint = TextView(ctx)
        hist_hint.setText(_tr("Количество постов в истории", "Posts history count"))
        hist_hint.setTextSize(14)
        hist_hint.setTextColor(_c(COLOR_TEXT_SEC))
        hist_hint.setPadding(_dp(4), 0, 0, _dp(8))
        self._list_container.addView(hist_hint)

        hist_card = LinearLayout(ctx)
        hist_card.setOrientation(LinearLayout.VERTICAL)
        hist_card.setPadding(_dp(20), _dp(20), _dp(20), _dp(20))
        hist_card.setBackground(self._bg_rounded(COLOR_CARD, COLOR_STROKE, stroke_dp=1, radius_dp=CORNER_RADIUS_DP))
        lp_hist = LinearLayout.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.WRAP_CONTENT)
        lp_hist.bottomMargin = _dp(16)
        self._list_container.addView(hist_card, lp_hist)

        hist_cur = _clamp_history_posts(self._history_posts)
        hist_tv = TextView(ctx)
        hist_tv.setText((_tr("Текущее значение", "Current value") + f": {hist_cur}"))
        hist_tv.setTextSize(16)
        hist_tv.setTextColor(_c(COLOR_TEXT_PR))
        hist_tv.setTypeface(None, Typeface.BOLD)
        hist_tv.setPadding(0, 0, 0, _dp(16))
        hist_card.addView(hist_tv)

        sb_hist = SeekBar(ctx)
        try:
            sb_hist.setMax(99)
            sb_hist.setProgress(max(0, min(99, int(hist_cur) - 1)))
        except Exception:
            pass
        hist_card.addView(sb_hist, LinearLayout.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.WRAP_CONTENT))

        def on_hist_progress(_sb, progress, from_user):
            try:
                if not from_user: return
                val = max(1, min(100, int(progress) + 1))
                hist_tv.setText((_tr("Текущее значение", "Current value") + f": {val}"))
            except Exception:
                pass

        def on_hist_stop(_sb):
            try:
                val = max(1, min(100, int(_sb.getProgress() or 0) + 1))
                self._apply_history_limit(val)
            except Exception:
                pass

        try:
            self._history_seek_listener = _OnSeekBarChangeListener(on_hist_progress, None, on_hist_stop)
            sb_hist.setOnSeekBarChangeListener(self._history_seek_listener)
        except Exception:
            pass

        card = LinearLayout(ctx)
        card.setOrientation(LinearLayout.VERTICAL)
        card.setPadding(_dp(20), _dp(20), _dp(20), _dp(20))
        card.setBackground(self._bg_rounded(COLOR_CARD, COLOR_STROKE, stroke_dp=1, radius_dp=CORNER_RADIUS_DP))
        lp_card = LinearLayout.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.WRAP_CONTENT)
        lp_card.bottomMargin = _dp(24)
        self._list_container.addView(card, lp_card)

        val_tv = TextView(ctx)
        val_tv.setText((_tr("Текущий масштаб", "Current scale") + f": {self._ui_scale_percent()}%"))
        val_tv.setTextSize(16)
        val_tv.setTextColor(_c(COLOR_TEXT_PR))
        val_tv.setTypeface(None, Typeface.BOLD)
        val_tv.setPadding(0, 0, 0, _dp(16))
        card.addView(val_tv)

        sb = SeekBar(ctx)
        max_progress = max(1, self._ui_scale_to_progress(_UI_SCALE_MAX))
        cur_progress = self._ui_scale_to_progress(self._ui_scale)
        try:
            sb.setMax(max_progress)
            sb.setProgress(max(0, min(max_progress, cur_progress)))
        except Exception: pass
        card.addView(sb, LinearLayout.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.WRAP_CONTENT))

        def on_progress(_sb, progress, from_user):
            try:
                if not from_user: return
                val = self._progress_to_ui_scale(int(progress))
                val_tv.setText((_tr("Текущий масштаб", "Current scale") + f": {int(round(val * 100))}%"))
            except Exception: pass

        def on_stop(_sb):
            try:
                val = self._progress_to_ui_scale(int(_sb.getProgress() or 0))
                self._apply_ui_scale_and_reopen(val)
            except Exception: pass

        try:
            self._ui_seek_listener = _OnSeekBarChangeListener(on_progress, None, on_stop)
            sb.setOnSeekBarChangeListener(self._ui_seek_listener)
        except Exception: pass

        reset_btn = self._primary_button(ctx, _tr("Сбросить: 100%", "Reset: 100%"), lambda: self._apply_ui_scale_and_reopen(1.0))
        self._list_container.addView(reset_btn, LinearLayout.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.WRAP_CONTENT))

        bg_hint = TextView(ctx)
        bg_hint.setText(_tr("Интервал автообновления в фоне (сек)", "Background auto-refresh interval (sec)"))
        bg_hint.setTextSize(14)
        bg_hint.setTextColor(_c(COLOR_TEXT_SEC))
        bg_hint.setPadding(_dp(4), _dp(20), 0, _dp(8))
        self._list_container.addView(bg_hint)

        bg_card = LinearLayout(ctx)
        bg_card.setOrientation(LinearLayout.VERTICAL)
        bg_card.setPadding(_dp(20), _dp(20), _dp(20), _dp(20))
        bg_card.setBackground(self._bg_rounded(COLOR_CARD, COLOR_STROKE, stroke_dp=1, radius_dp=CORNER_RADIUS_DP))
        lp_bg = LinearLayout.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.WRAP_CONTENT)
        lp_bg.bottomMargin = _dp(16)
        self._list_container.addView(bg_card, lp_bg)

        raw_bg = self.get_setting("bg_refresh_seconds", None)
        if raw_bg is None:
            try: raw_bg = int(round(float(self.get_setting("bg_refresh_minutes", "3")) * 60.0))
            except Exception: raw_bg = 180
        cur_bg = _clamp_bg_refresh_seconds(raw_bg)
        bg_tv = TextView(ctx)
        bg_tv.setText((_tr("Текущее значение", "Current value") + f": {cur_bg} сек"))
        bg_tv.setTextSize(16)
        bg_tv.setTextColor(_c(COLOR_TEXT_PR))
        bg_tv.setTypeface(None, Typeface.BOLD)
        bg_tv.setPadding(0, 0, 0, _dp(16))
        bg_card.addView(bg_tv)

        sb_bg = SeekBar(ctx)
        try:
            sb_bg.setMax(179)
            sb_bg.setProgress(max(0, min(179, int((cur_bg - 10) / 10))))
        except Exception: pass
        bg_card.addView(sb_bg, LinearLayout.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.WRAP_CONTENT))

        def on_bg_progress(_sb, progress, from_user):
            try:
                if not from_user: return
                val = max(10, min(1800, (int(progress) + 1) * 10))
                bg_tv.setText((_tr("Текущее значение", "Current value") + f": {val} сек"))
            except Exception: pass

        def on_bg_stop(_sb):
            try:
                val = max(10, min(1800, (int(_sb.getProgress() or 0) + 1) * 10))
                self.set_setting("bg_refresh_seconds", str(val))
                self.set_setting("bg_refresh_minutes", str(int(round(float(val) / 60.0))))
                bg_tv.setText((_tr("Текущее значение", "Current value") + f": {val} сек"))
            except Exception: pass

        try:
            self._bg_minutes_seek_listener = _OnSeekBarChangeListener(on_bg_progress, None, on_bg_stop)
            sb_bg.setOnSeekBarChangeListener(self._bg_minutes_seek_listener)
        except Exception: pass

        hint_corner = TextView(ctx)
        hint_corner.setText(_tr("Общее закругление интерфейса", "Global corner roundness"))
        hint_corner.setTextSize(14)
        hint_corner.setTextColor(_c(COLOR_TEXT_SEC))
        hint_corner.setPadding(_dp(4), _dp(20), 0, _dp(8))
        self._list_container.addView(hint_corner)

        card_corner = LinearLayout(ctx)
        card_corner.setOrientation(LinearLayout.VERTICAL)
        card_corner.setPadding(_dp(20), _dp(20), _dp(20), _dp(20))
        card_corner.setBackground(self._bg_rounded(COLOR_CARD, COLOR_STROKE, stroke_dp=1, radius_dp=CORNER_RADIUS_DP))
        lp_cc = LinearLayout.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.WRAP_CONTENT)
        lp_cc.bottomMargin = _dp(16)
        self._list_container.addView(card_corner, lp_cc)

        corner_tv = TextView(ctx)
        corner_tv.setText((_tr("Текущее закругление", "Current roundness") + f": {self._corner_scale_percent()}%"))
        corner_tv.setTextSize(16)
        corner_tv.setTextColor(_c(COLOR_TEXT_PR))
        corner_tv.setTypeface(None, Typeface.BOLD)
        corner_tv.setPadding(0, 0, 0, _dp(16))
        card_corner.addView(corner_tv)

        sb_corner = SeekBar(ctx)
        max_corner = max(1, self._corner_scale_to_progress(_CORNER_SCALE_MAX))
        cur_corner = self._corner_scale_to_progress(self._corner_scale)
        try:
            sb_corner.setMax(max_corner)
            sb_corner.setProgress(max(0, min(max_corner, cur_corner)))
        except Exception: pass
        card_corner.addView(sb_corner, LinearLayout.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.WRAP_CONTENT))

        def on_corner_progress(_sb, progress, from_user):
            try:
                if not from_user: return
                val = self._progress_to_corner_scale(int(progress))
                corner_tv.setText((_tr("Текущее закругление", "Current roundness") + f": {int(round(val * 100))}%"))
            except Exception: pass

        def on_corner_stop(_sb):
            try:
                val = self._progress_to_corner_scale(int(_sb.getProgress() or 0))
                self._apply_corner_scale_and_reopen(val)
            except Exception: pass

        try:
            self._corner_seek_listener = _OnSeekBarChangeListener(on_corner_progress, None, on_corner_stop)
            sb_corner.setOnSeekBarChangeListener(self._corner_seek_listener)
        except Exception: pass

        accent_hint = TextView(ctx)
        accent_hint.setText(_tr("Акцентный цвет", "Accent color"))
        accent_hint.setTextSize(14)
        accent_hint.setTextColor(_c(COLOR_TEXT_SEC))
        accent_hint.setPadding(_dp(4), _dp(16), 0, _dp(8))
        self._list_container.addView(accent_hint)

        accent_card = LinearLayout(ctx)
        accent_card.setOrientation(LinearLayout.VERTICAL)
        accent_card.setPadding(_dp(20), _dp(20), _dp(20), _dp(20))
        accent_card.setBackground(self._bg_rounded(COLOR_CARD, COLOR_STROKE, stroke_dp=1, radius_dp=CORNER_RADIUS_DP))
        lp_ac = LinearLayout.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.WRAP_CONTENT)
        lp_ac.bottomMargin = _dp(16)
        self._list_container.addView(accent_card, lp_ac)

        accent_tv = TextView(ctx)
        accent_tv.setText((_tr("Текущий акцент", "Current accent") + f": {self._accent()}"))
        accent_tv.setTextSize(16)
        accent_tv.setTextColor(_c(self._accent()))
        accent_tv.setTypeface(None, Typeface.BOLD)
        accent_tv.setPadding(0, 0, 0, _dp(16))
        accent_card.addView(accent_tv)

        sb_accent = SeekBar(ctx)
        palette = self._accent_palette()
        max_accent = max(0, len(palette) - 1)
        cur_accent = self._accent_to_progress(self._accent())
        try:
            sb_accent.setMax(max_accent)
            sb_accent.setProgress(max(0, min(max_accent, cur_accent)))
        except Exception: pass
        accent_card.addView(sb_accent, LinearLayout.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.WRAP_CONTENT))

        def on_accent_progress(_sb, progress, from_user):
            try:
                if not from_user: return
                col = self._progress_to_accent(int(progress))
                accent_tv.setText((_tr("Текущий акцент", "Current accent") + f": {col}"))
                accent_tv.setTextColor(_c(col))
            except Exception: pass

        def on_accent_stop(_sb):
            try:
                col = self._progress_to_accent(int(_sb.getProgress() or 0))
                self._apply_accent_and_reopen(col)
            except Exception: pass

        try:
            self._accent_seek_listener = _OnSeekBarChangeListener(on_accent_progress, None, on_accent_stop)
            sb_accent.setOnSeekBarChangeListener(self._accent_seek_listener)
        except Exception: pass

        accent_input = EditText(ctx)
        accent_input.setSingleLine(True)
        accent_input.setText(self._accent())
        accent_input.setHint("#FF7E57C2")
        accent_input.setTextColor(_c(COLOR_TEXT_PR))
        try: accent_input.setHintTextColor(_c(COLOR_TEXT_SEC))
        except Exception: pass
        accent_input.setBackground(self._bg_rounded("#14FFFFFF", radius_dp=14))
        accent_input.setPadding(_dp(14), _dp(12), _dp(14), _dp(12))
        lp_ai = LinearLayout.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.WRAP_CONTENT)
        lp_ai.topMargin = _dp(12)
        accent_card.addView(accent_input, lp_ai)

        apply_accent_btn = self._primary_button(ctx, _tr("Применить HEX", "Apply HEX"), lambda: self._apply_accent_and_reopen(str(accent_input.getText().toString())))
        lp_ab = LinearLayout.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.WRAP_CONTENT)
        lp_ab.topMargin = _dp(10)
        accent_card.addView(apply_accent_btn, lp_ab)

    def _render_subs(self, ctx):
        entries = self._get_sub_entries()

        top_row = LinearLayout(ctx)
        top_row.setOrientation(LinearLayout.HORIZONTAL)
        top_row.setGravity(Gravity.CENTER_VERTICAL)
        top_row.setPadding(_dp(4), _dp(10), 0, _dp(24))
        self._list_container.addView(top_row)

        h = TextView(ctx)
        h.setText(_tr("Подписки", "Subscriptions"))
        h.setTextSize(28)
        h.setTypeface(None, Typeface.BOLD)
        h.setTextColor(_c(COLOR_TEXT_PR))
        top_row.addView(h, LinearLayout.LayoutParams(0, ViewGroup.LayoutParams.WRAP_CONTENT, 1.0))
        
        plus_btn = self._primary_button(ctx, " + Добавить ", lambda: self._open_add_feed_screen(get_last_fragment()))
        # Немного уменьшим паддинги для кнопки в хедере
        plus_btn.setPadding(_dp(16), _dp(10), _dp(16), _dp(10)) 
        top_row.addView(plus_btn)

        if not entries:
            t = TextView(ctx)
            t.setText(_tr("Пусто.\nДобавьте RSS-ленту или ссылку на Telegram канал.", "Empty.\nAdd RSS feed or Telegram link."))
            t.setTextSize(15); t.setTextColor(_c(COLOR_TEXT_SEC)); t.setGravity(Gravity.CENTER)
            t.setPadding(_dp(12), _dp(40), _dp(12), _dp(20))
            self._list_container.addView(t)
        else:
            for idx, it in enumerate(entries):
                sub = str(it.get("sub") or "")
                cat = _norm_category(it.get("category", ""))
                
                row = LinearLayout(ctx)
                row.setOrientation(LinearLayout.HORIZONTAL)
                row.setGravity(Gravity.CENTER_VERTICAL)
                row.setPadding(_dp(16), _dp(16), _dp(12), _dp(16))
                row.setBackground(self._bg_rounded(COLOR_CARD, COLOR_STROKE, stroke_dp=1, radius_dp=20))
                lp_row = LinearLayout.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.WRAP_CONTENT)
                lp_row.bottomMargin = _dp(12)
                self._list_container.addView(row, lp_row)
                
                if self._animate_list_once and idx < 12: self._animate_entry(row, idx)

                show = _sub_to_label(sub)
                is_excluded = sub in set(self._sub_exclude_filters or [])

                txt_col = LinearLayout(ctx)
                txt_col.setOrientation(LinearLayout.VERTICAL)
                row.addView(txt_col, LinearLayout.LayoutParams(0, ViewGroup.LayoutParams.WRAP_CONTENT, 1.0))

                tv = TextView(ctx)
                tv.setText(show)
                tv.setTextSize(16)
                tv.setTypeface(None, Typeface.BOLD)
                tv.setTextColor(_c("#FFFF6B6B" if is_excluded else COLOR_TEXT_PR))
                txt_col.addView(tv)

                if cat:
                    tv_cat = TextView(ctx)
                    tv_cat.setText((_tr("Категория", "Category") + f": {cat}"))
                    tv_cat.setTextSize(13)
                    tv_cat.setTextColor(_c(COLOR_TEXT_SEC))
                    tv_cat.setPadding(0, _dp(4), 0, 0)
                    txt_col.addView(tv_cat)

                ex_btn = self._top_button(ctx, _tr(" исключить ", " exclude "), lambda key=sub: self._toggle_sub_exclude_filter(key))
                if is_excluded:
                    ex_btn.setBackground(self._bg_rounded("#33FF3B30", radius_dp=16))
                    try: ex_btn.setAlpha(1.0)
                    except Exception: pass
                else:
                    ex_btn.setBackground(self._bg_rounded("#1AFFFFFF", radius_dp=16))
                    try: ex_btn.setAlpha(0.85)
                    except Exception: pass

                cat_btn = self._top_button(ctx, " ✎ ", lambda key=sub: self._open_category_screen(key))
                delb = self._top_button(ctx, " ✕ ", lambda key=sub: self._remove_sub(key))
                delb.setBackground(self._bg_rounded("#26FF3B30", radius_dp=16)) # Red warning color
                
                row.addView(ex_btn)
                row.addView(self._spacer_h(ctx, 8))
                row.addView(cat_btn)
                row.addView(self._spacer_h(ctx, 8))
                row.addView(delb)

    def _set_main_overlays_visibility(self, visible: bool):
        vis = View.VISIBLE if visible else View.GONE
        for ov in (self._overlay, self._add_overlay, self._cat_overlay, self._src_overlay, self._post_overlay, self._img_overlay):
            if ov is None: continue
            try: ov.setVisibility(vis)
            except Exception: pass

    def _close_mini_overlay(self, animated: bool = True):
        mini = self._mini_overlay
        if mini is None: return
        def detach():
            try:
                parent = mini.getParent()
                if parent and isinstance(parent, ViewGroup): parent.removeView(mini)
            except Exception: pass
            self._mini_overlay = None; self._mini_link = ""; self._mini_back_listener = None; self._back_tracking_paused = False
        if not animated: detach(); return
        try: mini.animate().alpha(0.0).scaleX(0.9).scaleY(0.9).setDuration(150).start()
        except Exception: detach(); return
        try: AndroidUtilities.runOnUIThread(Runnable(detach), 160)
        except Exception: run_on_ui_thread(detach)

    def _dismiss_mini_and_close_plugin(self):
        self._back_tracking_paused = False
        self._set_main_overlays_visibility(True)
        self._close_mini_overlay(animated=True)
        try:
            self._close_source_picker_screen(animated=False)
            self._close_add_feed_screen(animated=False)
            self._close_category_screen(animated=False)
            self._close_post_screen(animated=False)
            self._close_image_screen(animated=False)
            self._close(animated=False)
        except Exception: pass

    def _restore_from_mini(self):
        self._back_tracking_paused = False
        self._set_main_overlays_visibility(True)
        try:
            for ov in (self._overlay, self._add_overlay, self._cat_overlay, self._src_overlay, self._post_overlay, self._img_overlay):
                if ov is None: continue
                ov.setAlpha(0.0)
                ov.animate().alpha(1.0).setDuration(200).start()
        except Exception: pass
        self._close_mini_overlay(animated=True)

    def _minimize_to_mini_overlay(self, fragment, link: str):
        if self._mini_overlay is not None:
            self._mini_link = str(link or "")
            return
        if not fragment: fragment = get_last_fragment()
        if not fragment: return
        activity = fragment.getParentActivity()
        if not activity: return
        decor = activity.getWindow().getDecorView()
        if not isinstance(decor, ViewGroup): return

        self._set_main_overlays_visibility(False)
        self._back_tracking_paused = True

        mini = FrameLayout(activity)
        mini.setClickable(True); mini.setFocusable(True)
        mini.setBackground(self._bg_rounded(COLOR_CARD, COLOR_STROKE, stroke_dp=1, radius_dp=24))
        mini.setPadding(_dp(16), _dp(16), _dp(16), _dp(16))
        try: mini.setMinimumWidth(_dp(220)); mini.setElevation(_dp(16))
        except Exception: pass

        row = LinearLayout(activity)
        row.setOrientation(LinearLayout.HORIZONTAL)
        row.setGravity(Gravity.CENTER_VERTICAL)
        mini.addView(row)

        close_btn = TextView(activity)
        close_btn.setText("✕")
        close_btn.setTextSize(16)
        close_btn.setTextColor(_c(COLOR_TEXT_PR))
        close_btn.setAlpha(0.6)
        close_btn.setClickable(True)
        close_btn.setPadding(0, 0, _dp(16), 0)
        close_btn.setOnClickListener(OnClickListener(lambda _v: self._dismiss_mini_and_close_plugin()))
        row.addView(close_btn)

        title_col = LinearLayout(activity)
        title_col.setOrientation(LinearLayout.VERTICAL)
        row.addView(title_col, LinearLayout.LayoutParams(0, ViewGroup.LayoutParams.WRAP_CONTENT, 1.0))

        title = TextView(activity)
        title.setText(_tr("ExteraRSS свернут", "ExteraRSS minimized"))
        title.setTextSize(15)
        title.setTypeface(None, Typeface.BOLD)
        title.setTextColor(_c(COLOR_TEXT_PR))
        title_col.addView(title)

        sub = TextView(activity)
        sub.setText(_tr("Нажмите, чтобы вернуться", "Tap to return"))
        sub.setTextSize(13)
        sub.setTextColor(_c(COLOR_TEXT_SEC))
        sub.setPadding(0, _dp(2), 0, 0)
        title_col.addView(sub)

        mini.setOnClickListener(OnClickListener(lambda _v: self._restore_from_mini()))

        lp = FrameLayout.LayoutParams(ViewGroup.LayoutParams.WRAP_CONTENT, ViewGroup.LayoutParams.WRAP_CONTENT)
        lp.gravity = int(Gravity.END | Gravity.BOTTOM)
        lp.rightMargin = _dp(16); lp.bottomMargin = _dp(24)
        decor.addView(mini, lp)
        self._bind_back_handler(mini, lambda: self._handle_back_action(), "_mini_back_listener")

        try:
            mini.setAlpha(0.0); mini.setScaleX(0.8); mini.setScaleY(0.8)
            mini.animate().alpha(1.0).scaleX(1.0).scaleY(1.0).setDuration(250).setInterpolator(OvershootInterpolator(1.2)).start()
        except Exception: pass
        self._mini_overlay = mini; self._mini_link = str(link or "")

    def _remove_sub(self, sub_key: str):
        if not sub_key: return
        entries = [x for x in self._get_sub_entries() if str(x.get("sub") or "") != sub_key]
        self._set_sub_entries(entries)
        if self._sub_exclude_filters:
            self._sub_exclude_filters = [x for x in self._sub_exclude_filters if x != sub_key]
            try:
                self.set_setting("sub_exclude_filters", json.dumps(self._sub_exclude_filters, ensure_ascii=False))
            except Exception:
                pass
        # Если подписка удалена полностью — чистим связанные кэш-записи.
        old_cache = self._get_cache()
        kept = []
        for it in old_cache:
            src_handle = str(it.get("source_handle", "") or "").strip()
            src = str(it.get("source", "") or "").strip()
            drop = False
            if src_handle.startswith("@") and sub_key.startswith("tguser:"):
                drop = (_norm_sub("tguser:" + src_handle[1:]) == sub_key)
            if (not drop) and src:
                drop = (_norm_sub(src) == sub_key)
            if not drop:
                kept.append(it)
        if len(kept) != len(old_cache):
            self._set_cache(kept)
        self._render()
        if self._overlay is not None: self._set_refreshing_ui(True)
        self._refresh_async()

    # ---------- open link ----------
    def _open_link(self, fragment, link: str):
        if not link: return
        if not fragment: fragment = get_last_fragment()
        if not fragment: return
        activity = fragment.getParentActivity()
        if not activity: return
        try:
            self._minimize_to_mini_overlay(fragment, link)
            intent = Intent(Intent.ACTION_VIEW, Uri.parse(link))
            activity.startActivity(intent)
        except Exception: pass
